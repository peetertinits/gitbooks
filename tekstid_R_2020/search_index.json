[
["index.html", "Lihtne tekstitöötlus R-is ja tidyverse’is Peatükk 1 Tekstitöötlus R-is ja tidyverse-is 1.1 Juhend 1.2 Sisukord", " Lihtne tekstitöötlus R-is ja tidyverse’is Peeter Tinits 26 märts, 2020 Peatükk 1 Tekstitöötlus R-is ja tidyverse-is Need materjalid annavad sissejuhatuse tekstitöötlusesse R-is, tidyverse pakettide abil. Materjalid on kujundatud nii, et need oleksid läbitavad ka puhtalt kaugõppes. 1.1 Juhend Õppetüki läbimiseks tuleb: Laadida alla materjalidega seotud failid. Need on saadaval moodle’is või siin. Märkus, viimase lingi taga on ka mõned abifailid, millest võib olla abi kui R-i pärast kursust edasi õppida. Läbi käia kõik .R failid kataloogis code/. Failides on kasutusjuhend kirjutatud kommentaaridena (roheline tekst trellide # järel) Läbimiseks käivita iga käsurida faili algusest lõpuni. Kirjuta vastuseid ja märkmeid koodi vahele. Täiendatud .R failid on soovitav säilitada juhuks kui tulevikus on vaja koodi kirjutada. Iga õppetüki lõpus on ka harjutusülesanded. Nende tegemine ei ole kohustuslik. Läbimise kontrolliks tuleb: Täita Moodle-is enesekontrolli test. Esitada täidetud eksamitöö. Eksamitöö on failis 6_eksamitöö.R e-õppe materjalide hulgas. Materjal on osaliselt kattuv juba tundides läbituga ning on arvestatud, et uue materjaliga tutvumine võiks kokku nõuda 8 akadeemilise tunni jagu tööaega. Sellele lisaks on kodutööks enesekontroll ja eksamitöö. 1.2 Sisukord R, RStudio ja selle kasutamine oma arvutis R-i alused Tidyverse paketid Tidytext ja tekstitöötlus Mitmikud, regulaaravaldised ja märksõnad Graafikute loomine R-is "],
["mis-on-r-mis-on-rstudio.html", "Peatükk 2 Mis on R? Mis on RStudio? 2.1 RStudio oma arvutis 2.2 Installimine 2.3 Rstudio Cloud 2.4 Materjalide avamine 2.5 RStudio tutvustus 2.6 Stiilisoovitus 2.7 Soovitatav kirjandus", " Peatükk 2 Mis on R? Mis on RStudio? R on programmeerimiskeel ja vabavaraline arenduskeskkond, mis on mõeldud eelkõige andmete töötluseks, analüüsiks ja visuaalseks kuvamiseks. RStudio on abivahend, mis hõlbustab ja toetab R-i kasutamist sedavõrd, et võiks arvata, et tegemist on juba uue keskkonnaga. RStudio töötab hästi tavalises isiklikus arvutis (Windows, Mac, Linux jne), aga seda on võimalik kasutada ka läbi interneti. R-i saab kasutada ka ilma RStudiota ning kõik funktsioonid töötavad seal. RStudio teeb aga R-i kasutamise oluliselt lihtsamaks. 2.1 RStudio oma arvutis 2.2 Installimine Isiklikule arvutile installige kõigepealt R (viimane versioon on ok) ja seejärel RStudio (viimane versioon on ok). Installimiseks antakse täpsed ja uusimad juhised järgnevatel lehtedel. Installige R: https://cran.rstudio.com/ Windows: https://cran.rstudio.com/bin/windows/base/ Mac: https://cran.rstudio.com/bin/macosx/ Linux: https://cran.rstudio.com/bin/linux/ (vt readme-d) Installige RStudio: https://www.rstudio.com/products/rstudio/download/ 2.3 Rstudio Cloud Ilma installimata on võimalik kasutada ka RStudio Cloudi: https://rstudio.cloud/. Tehke endale kasutaja ‘sign up’ kaudu ning logige sisse. Iga oma RStudio töö jaoks võib siis teha eraldi projekti. 2.4 Materjalide avamine Materjalid on jagatud eraldi .zip failis, mis tuleb alla laadida. Selle avamiseks RStudios on mitmeid võimalusi. 2.4.1 Isiklikus arvutis Isiklikus arvutis pakkige kõigepealt failid lahti (extract). Kui klikkida selle peale Windowsis, siis mõnikord avab ta faile üksikuna .zipi sees, mis siin ei toimi. Kui failid on avatud ja RStudio installitud, võib lihtsalt klikkida .Rproj failile. See avab RStudio õigest kohast nii, et kõik on juba seadistatud. Projektifaili võib avada ka RStudios vajutades kõigepealt paremal ülal nurgas olevale “Project: (None)” tekstile. Ja sealt Open project ja suunata see Rproj failile. Projektifaili kasutamine seab paika ka töökataloogi. Kui projektifaili mitte kasutada, on oluline seadistada töökataloog. Selle jaoks vajutage alumise parempoolse kasti juures, kus on failid (veenduge, et Files sälk oleks valitud) ülal paremal kolme punktiga tähistatud kohale. Seejärel avaneb aken, kus liikuda õigesse kohta. Kui olete lahtipakitud kataloogis, siis valige ülalt sinise hammasratta kõrvalt More ja Set As Working Directory. See käivitab konsoolis ka esimese käsu setwd(), mis seab kataloogi paika. Edaspidi saab kopeerida selle käsu näiteks faili algusesse, et saada kohe õigesse kohta. Töökataloogi on võimalik kontrollida käsuga getwd(). 2.4.2 Pilves Materjalide avamiseks RStudio Cloud-is tuleks kõigepealt luua projekt oma kasutajanime all. Ning projektis on näha sarnane koht failidega. Seal valida koht Upload - kus saab valida terve .zip faili, mis siis seal lahti pakitakse. Võib kasutada ka RStudiot pilves 2.5 RStudio tutvustus RStudio vaade on tüüpiliselt selline nagu ülal näha. Akende asukohti saab muuta ja nende suhtelisi suurusi saab muuta, aga alguses on neid hea hoida paiga. Vasakul-ülal on skriptiaken; paremal-ülal on muutujad ja käskude ajalugu; vasakul-all on konsool, kus jookseb kood; paremal-all on failid, graafikud ja abi. 2.6 Stiilisoovitus Veel üks stiilisoovitus. Lülitada sisse word-wrap ehk soft-wrap Selleks leia menüüst järgmine koht: Tools -&gt; Global options -&gt; Code -&gt; Editing -&gt; Soft-wrap R source files (lülita see sisse) 2.7 Soovitatav kirjandus Lisamaterjalina soovitan kahte vabalt kättesaadavat teost. Garrett Grolemund, Hadley Wickham. 2017. R for Data Science. O’Reilly Media https://r4ds.had.co.nz/ Julia Silge and David Robinson. 2017. Text Mining with R: A Tidy Approach. O’Reilly Media https://www.tidytextmining.com/ "],
["r-i-alused.html", "Peatükk 3 R-i alused 3.1 R ja käsud 3.2 R lihtsa kalkulaatorina 3.3 Tulemuste salvestamine 3.4 Tehete järjekord 3.5 Võrdused ja võrratused 3.6 Muutujate nimed ja tekst 3.7 Jadad 3.8 R paketid", " Peatükk 3 R-i alused 3.1 R ja käsud Suhtlus R-iga käib käskude kaudu. Sisestades R-is käsu ja vajutades ENTERit püüab R selle tulemust välja arvutada ja salvestada kui selleks on juhised antud. Skriptid koondavad kokku hulga käske, mida võib järgemööda käivitada. Skriptidesse on hea käske koondada, kuna siis võib kunagi hiljem töötluskäigu täpselt taastada, seda võib kergesti parandada ja see töötab ka kellegi teise arvutis. Skriptifaile koostatakse üldiselt niimoodi, et kui otsast käske käivitada, siis jookseb skript kenasti lõpuni. Sellest tuleb ka pöidlareegel, et kui mõnes salvestatud skriptifailis mõni varemsalvestatud käsk ei tööta, võib proovida faili algusest peale kõik uuesti läbi teha ja vaadata, kas viga on ikka olemas. Kui on, siis võib olla probleem salvestatud skriptis. R-is saab salvestada skripte lihtsas skriptifailis, millel on .R lõpp või siis Rmarkdown failis, millel on .Rmd lõpp. Rmarkdown on lisamoodul R-is mis aitab teksti ja koodi hoida samas failis. Nii .R kui .Rmd failis või RStudio kaudu käske käivitada ühekaupa. Üldiselt on käsk ühe rea peal, ning selle käivitamiseks tuleb viia oma tekstikursor sellele reale ja vajutada Windowsis ja Linuxis CTRL+ENTER, Mac-is CMD+ENTER. Sama käsk on ka RStudios ülal Run all Run -&gt; Run selected line(s). Tekstikursoriga saab valida ka mitu rida või osa ühest või mitmest reast ja kui osa teksti on valitud, siis käivitab R ainult selle. Käsu jooksutamiseks konsooliaknas (RStudios all vasakul) kasutage lihtsalt ENTER. Peaaegu kõikide käskude puhul on võimalik lisada käsu ette küsimärk, mille käivitamisel ilmub paremalle alla nurka selle käsu kasutusjuhend. ?read.csv 3.2 R lihtsa kalkulaatorina Näiteks võib lasta tal arvutada lihtsamat matemaatikat. Näiteks võime käsuks anda lihtsalt 5+7 ja R käivitab selle ning trükib välja tulemuse. 5 + 7 ## [1] 12 Tulemus on näha ülal. Kui käivitad käsu RStudios, jõuab tulemus konsooli. 5 ja 7 olid sisendnumbrid ja + oli operatsioon, mille R tegi, mis antud juhul tähendas liitmist. R-is saab ka teha teisi tehteid. 1+1 ## [1] 2 4-2 ## [1] 2 4*2 ## [1] 8 27*17 ## [1] 459 459/17 ## [1] 27 sqrt(25) ## [1] 5 Tärn tähistab kordusmärki ja kaldkriips jagamist. sqrt() võtab ruutjuure sellest numbrist. Viimane ongi tüüpiline viis R-ile käske anda funktsioon(sisend) Tidyverse-s on selle kõrval teine tava. andmed %&gt;% funktsioon() Nad mõlemad teevad täpselt sama asja, lihtsal Tidyverse-i võtab vaikimisi sissesöödetud andmed funktsiooni sisendiks. Sellest rohkem peagi. 3.3 Tulemuste salvestamine Kui R-i võib kasutada lihtsa kalkulaatorina, siis selle jõud tuleb välja siis kui tuleb mingit andmehulka või tehteid korduvalt kasutada. Selle jaoks on võimalik nii andmeid kui funktsioone R-is kergesti salvestada. Tavaliselt kasutatakse salvestamiseks noolt &lt;-, mis on koostatud väiksem-kui märgist ja sidekriipsust. Üksikut võrdusmärki = saab aga kasutada enamasti samas tähenduses. Seda märki saab teha ka vajutades korraga alla ALT + - ehk ALT + miinusmärk. Tähele tuleb panna, et üksik võrdusmärk = ja topelt võrdusmärk == on R-is erinevas tähenduses. Me võime alustuseks teha muutuja x, mille sisuks on 5 + 7. Selleks kirjuta x &lt;- 5 + 7.&quot; x &lt;- 5 + 7 Kui R salvestab tulemuse muutujasse, ei trüki ta seda enam välja. Seda seepärast, et ta salvestamise juures eeldab, et me soovime sellega midagi veel teha. Et vaadata muutuja sisu, trükime selle lihtsalt sisse. x ## [1] 12 Me võime muutujat omakorda kasutada uue muutuja loomiseks. Näiteks loome muutuja y, mis koosneb x-st ja 3-st. R otsib üles x-i väärtuse ja kasutab seda y-i arvutamiseks. Kui x poleks määratud, siis R sellist y-it vastu ei võtaks. y &lt;- x - 3 Me võime vaadata y-i väärtust nüüd samamoodi. y ## [1] 9 Seejuures kui me nüüd muudame x-i tagantjärele, siis y enam ei muutu. Muudame x-i neljaks ja vaatame, et y-i väärtus säilib ikka. x &lt;- 4 y ## [1] 9 X-i saab määrata nii noole &lt;- kui ka võrdusmärgi = abil. Järgmised operatsioonid on võrdsed. x &lt;- 4 x = 4 3.4 Tehete järjekord Muutujate tegemisel on oluline operatsioonide järjekord. Samamoodi nagu matemaatikas tehete järjekorra määramiseks, saame järjekorda R-is määrata sulgude kaudu. Näiteks tavamatemaatikaga sarnaselt on järgmised kaks tehet erinevad. z &lt;- x+y*2 z ## [1] 22 z &lt;- (x+y)*2 z ## [1] 26 3.5 Võrdused ja võrratused Väga sagedasti on meil andmetöötlusel vaja kahte väärtust võrrelda. Näiteks leida kõik inimesed, kes on vanemad kui 60 või siis kõik andmed, mis pärinevad 2010 jaanuarikuust. Selleks on R-is kasutusel hulk viise kontrollida samasust ja erinevust. Kaks võrdusmärki == kontrollib, kas kaks objekti on täpselt võrdsed ja vastab sellele, kas TRUE või FALSE ehk kas tõene või väär. Koodi kirjutades võib TRUE ja FALSE lühendada vastavalt T ja F. 1==1 ## [1] TRUE 1==2 ## [1] FALSE x==4 ## [1] TRUE x==y ## [1] FALSE x==y*2 ## [1] FALSE Eitust märgitakse nendes kontrollides hüüumärgiga !. Võrdsusetuse kontrollimiseks võime kasutada märki hüüumärki koos võrdusmägiga != või asetada hüüumärgi ! kontrolllause ette. Kõik järgnevad laused kontrollivad hüüumärgi kaudu ühenduse eitust. 1!=1 ## [1] FALSE 1!=2 ## [1] TRUE !1==1 ## [1] FALSE !1==2 ## [1] TRUE Lisaks võrdsusele saame numbrite puhul kontrollida ka kas esimene number on väiksem kui &lt;, suurem kui &gt;, väiksem/võrdne &lt;= või suurem/võrdne &gt;= teisest numbrist. 1 &lt; 1 ## [1] FALSE 2 &gt; 1 ## [1] TRUE 1 &lt;= 1 ## [1] TRUE 2 &gt;= 2 ## [1] TRUE 3.6 Muutujate nimed ja tekst R-is töödeldakse lisaks numbritele ka teksti. Et mitte segamini ajada muutujate nimesid ja teksti, peab tekst olema alati jutumärkides. Kui me kirjutame x või y ilma jutumärkideta, otsib R üles need muutujad ja väljastab nende väärtuse. Kui me tahame, et R mõistaks x-i ja y-it tekstina, peame need ümbritsema jutumärkidega, kas ühekordsete (‘näidis’) või kahekordsetega (“näidis”).&quot; x ## [1] 4 y ## [1] 9 &#39;x&#39; ## [1] &quot;x&quot; &quot;y&quot; ## [1] &quot;y&quot; Seni kuni ta on tekstijupi sees on ta ükskõik kui pikk, võib sisaldada tühikuid ja muid märke. &quot;Siin on kirjutatud lause ühe tekstielemendina.&quot; ## [1] &quot;Siin on kirjutatud lause ühe tekstielemendina.&quot; Ja sellegi saame me salvestada samamoodi. a &lt;- &quot;Siin on kirjutatud lause ühe tekstielemendina.&quot; Seejuures võib muutujate nimeks olla peaaegu ükskõik mis. Muutuja ei või ainult alata numbriga, sisaldada tühikuid sidekriipse, kooloneid, trelle ja muud, millel on R-i algsüntaksis juba tähendus. Muutuja võib kasutada suuri ja väikseid tähti. Näiteks võime teha muutuja kuuliLennuTeeTunneliLuuk. kuuliLennuTeeTunneliLuuk &lt;- &quot;Siin on kirjutatud lause ühe tekstielemendina.&quot; Üldiselt on ka soovitus, et muutujate nimed võiksid olla pigem informatiivsed kui a, b ja c, kuna kuue kuu pärast ei mäleta enam keegi, mis see a täpselt oli, ilma hoolikalt koodi lugemata. Kui me aga unustame tekstielemendi ümber jutumärgid, siis annab R meile veateate. Ta ei leia sellist objekti üles. tundmatumuutujanimi # Error: object &#39;tundmatumuutujanimi&#39; not found. Selliseid veateateid annab R üldse kui kuskil on koodis viga ning R ei suuda seda käivitada. Tihti tuleb ette, et kuskil on sulud vales kohas või sulgemata ja R arvab, et miski peaks olema objekt kuigi see on mõeldud funktsioonina. Kui oma silm kohe viga ei leia, tasub panna veateade google-isse. Kuna sarnased probleemid tulevad teistelgi sagedasti ette, siis on tihti seal esimese vastusena lahendus olemas. 3.7 Jadad Tavaliselt töötab R rohkem kui ühe väärtusega korraga kasutades jadasid ehk vektoreid. Jadasid võib teha näiteks numbritest või tekstijuppidest, aga näiteks ka tabelitest (nendest siin õppetükis ei räägi). Selleks on kaks lihtsamat võimalust. Kooloniga : saab teha numbrijärjendi ja c() funktsiooniga saab teha järjendi numbritest või tekstielementidest. Sarnaseid funktsioone on veel, nt seq() või rep(), mida saate ise edasi uurida. Näiteks all on jadad 1 kuni 10 ja a, b, c. 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; Ka c()-ga võib teha jadasid, samuti võib sinna panna muutujate nimesid. Kui jada sisaldab vähemalt ühte tekstielementi, teeb ta ka kõik numbrid tekstiks. Jad elemendiks võib olla ka teine jada, c() käsk seab nad kõik samale tasapinnale x &lt;- 4 c(&quot;a&quot;, 1, x) ## [1] &quot;a&quot; &quot;1&quot; &quot;4&quot; c(1, 4, 8) ## [1] 1 4 8 c(1:8, 2, 4) ## [1] 1 2 3 4 5 6 7 8 2 4 c(4, 6, c(1, 2, 3)) ## [1] 4 6 1 2 3 Et kontrollida, kas miski element on olemas jadas, kasutatakse käsku %in%. %in% kontrollib, kas esimest elementi leidub teises 1 %in% 1:10 ## [1] TRUE Samaaegselt võib kontrollida ka mitut elementi ühes jadas. Järgmine kontrollib, millised elemendid jadast 2 kuni 10 on ühtlasi jadas 1 kuni 5 2:10 %in% 1:5 ## [1] TRUE TRUE TRUE TRUE FALSE FALSE FALSE FALSE FALSE Sama võib teha ka tekstijadaga. c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;f&quot;) %in% c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;) ## [1] TRUE TRUE TRUE FALSE Ka %in% märki saab kombineerida hüüumärgiga. !2:10 %in% 1:2 ## [1] FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE Vektoreid saab samamoodi salvestada nagu muid R-i objekte numbrivektor &lt;- 1:10 numbrivektor ## [1] 1 2 3 4 5 6 7 8 9 10 tekstivektor &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;,&quot;e&quot;,&quot;f&quot;,&quot;g&quot;,&quot;h&quot;,&quot;i&quot;,&quot;j&quot;) tekstivektor ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; Lisaks numbritele ja tekstidele on R-is veel üks oluline vektoritüüp, faktor. Faktorid on kategoorilised muutujad, kus väike hulk tüüpe, mis korduvad. faktor &lt;- factor(c(&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;)) faktor ## [1] a a a a a b b b b b ## Levels: a b Näiteks ülal on siis 10 elemendi pikkune faktor, kus on kaks tüüpi a ja b. Faktoril on niisiis lisaks jadale oluliseks selle tasandid levels(). levels(faktor) ## [1] &quot;a&quot; &quot;b&quot; Tasandeid saab ümber nimetada, muutes neid kogu jada ulatuses. levels(faktor) &lt;-c(&quot;naine&quot;,&quot;mees&quot;) faktor ## [1] naine naine naine naine naine mees mees mees mees mees ## Levels: naine mees Ning tasandite järjestust saab muuta. Tasandite järjestuse muutmine ei muuda jada ennast. Tüüp a jääb a-ks ja tüüp b jääb b-ks. faktor &lt;-factor(faktor,levels=c(&quot;mees&quot;,&quot;naine&quot;)) faktor ## [1] naine naine naine naine naine mees mees mees mees mees ## Levels: mees naine Tasandite järjestus mängib olulist rolli mudelite ja graafikute loomisel. Failide sisselugemisel tasub kontrollida, et tekstitulp ei oleks sisseloetud faktorina. R on traditsiooniliselt seda teinud ning selle vea kõrvaldamata jätmine on viinud valede tulemusteni nii mõnegi avaldatud teadustöö. Tidyverse paketid andmete sisselugemisel enam faktoreid vaikimisi ei lisa. Selle muutmiseks tuleb silmas pidada parameetrit stringsAsFactors. 3.8 R paketid Lisaks põhikäskudele on R-is hulk lisapakette, mis avavad uusi kasutusvõimalusi ning teevad olemasolevaid võimalusi mugavamaks. Praeguse õppetüki fookuses olev tidyverse on pakettide komplekt, mis püüab teha mõlemat. Iga paketi puhul tuleb see R-is esiteks 1) arvutisse installida ja teiseks 2) iga kord R-i või RStudiot käivitades sisse lülitada. Paketi installimiseks on olemas käsk install.packages(). Sama käsu leiab ka ülalt menüüst Tools -&gt; Install Packages… alt, kus saab kirjutada endale soovitavad paketid komadega eraldatult sisse. RStudio pakub ka kirjutamise ajal välja, mis paketid need võiksid olla. Uuemates RStudio versioonides on ka mõnikord skriptiakna kohal teade, et teatud paketid on installimata, kas soovite neid installida. Kui vajutada seal install, siis käivitab R sama install.packages() protsessi. Installime kõigepealt oma arvutisse tidyverse paketid. See võtab natuke aega, las arvuti töötab. Konsoolis näidatakse installikäiku, seal võib olla punast teksti ja hoiatusi, aga kui lõpuks on teade “* DONE (tidyverse)”, on kõik hästi. RStudios hakkab installimise ajal vilkuma punane stopnupp konsooli ülal-paremal otsas. Ärge sinna vajutage. Kui vajutate võib installimine katki minna. Kui see millegipärast on juhtunud, siis enamasti aitab remove.packages() samadele pakettidele ja siis uuesti proovida. install.packages(&quot;tidyverse&quot;) Paketi sisselugemiseks kasutame funktsiooni library(). Peaaegu samaväärne funktsioon on require() kui mõnikord skriptides on just seda kasutatud. Loeme kõigepealt sisse library(tidyverse). library(tidyverse) ## ── Attaching packages ────────────────────────────────────────────────────────────── tidyverse 1.3.0 ── ## ✓ ggplot2 3.2.1 ✓ purrr 0.3.3 ## ✓ tibble 2.1.3 ✓ dplyr 0.8.4 ## ✓ tidyr 1.0.2 ✓ stringr 1.4.0 ## ✓ readr 1.3.1 ✓ forcats 0.4.0 ## ── Conflicts ───────────────────────────────────────────────────────────────── tidyverse_conflicts() ── ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() Tidyverse käivitamisel võiks teie isiklikus arvutis näha midagi sellist. Ta näitab seal ka paari konflikti, aga nende pärast ei pea praegu muretsema. Neid tuleb teinekord ette kui uues paketis on mõni käsk sama nimega kui mõnes teises sisselaetud paketis. Sellisel juhul arvab R, et viimasena laetud funktsioon on õigeim. Väljatrükitust on näha, et R-i on sisselaetud paketid ggplot2, purr, tibble, dplyr, tidyr, stringr, readr ja forcats. Enamik pakette loevad sisse iseenda + enda töötamiseks vajalikud abipaketid (mida võib olla terve hulk). Tidyverse on üks väheseid pakette, mis loeb terve komplekti, mistõttu teised paketid võivad näidata teistlaadi teateid või, tavapäraselt, ei näitagi mingeid teateid. Senikaua kuni R veateadet ei näita library() käsu puhul, peaks olema kõik hästi. "],
["tidyverse-paketid.html", "Peatükk 4 Tidyverse paketid 4.1 Paketid 4.2 R ja andmed 4.3 Tidy andmestruktuurid 4.4 Tidyverse andmetöötlus 4.5 filter(), select(), unique(), sample_n() 4.6 count(), group_by() 4.7 arrange(), mutate(), row_number(), summarise(), n() 4.8 group_by() kasutamine 4.9 Käskude ühendamine 4.10 Uue muutuja loomine 4.11 Sõnastik 4.12 Harjutusülesanded", " Peatükk 4 Tidyverse paketid 4.1 Paketid Selles peatükis teeme algust tidyverse paketi kasutamisega. Paketid annavad R-i kasutades olulisi lisavõimalusi nagu sai kirjeldatud eelmises peatükis. Iga pakett tuleb kõigepealt installida. Tavapakettide puhul piisab selleks käsust install.packages(), millele tuleb sisendiks anda paketi nimi jutumärkides. Käivitage järgnev käsk. Kui tidyverse pole arvutisse varem installitud, installib R selle nüüd. Kui pakett on juba installitud, püüab R seda uuendada. install.packages(&quot;tidyverse&quot;) Paketi sisselugemiseks kasutame funktsiooni library(). Peaaegu samaväärne funktsioon on require() kui mõnikord skriptides on just seda kasutatud. Loeme kõigepealt sisse library(tidyverse). library(tidyverse) Tidyverse loetleb avamisel avatud paketid ja mainib paari konflikti teiste pakettide pärast, mille pärast Sa ei pea parasjagu muretsema. Kontrolli, kas Su konsoolis näitas midagi sarnast nagu siin juhendis ülal. Vajalikud paketid tuleb avada iga kord pärast Rstudio käivitamist, R ei tee eeldusi selle kohta, milliseid pakette Sul võiks vaja minna.. 4.1.1 Tidyverse arvutiklassis Mõnede pakettide installimine nõuab arvutis rohkem kui tavakasutaja ligipääsu. Hiljaeaegu sai ka Tidyverse nende pakettide hulka ja kui ligipääsuõiguseid ei ole, nagu näiteks arvutiklassis, siis on vaja teha veel järgmist. Isiklikus arvutis ei ole tõenäoliselt seda vaja teha. Kui tidyverse sisselaadimine ülal töötas, jäta see osa vahele. JUHUL KUI eelolev ei töötanud täpselt nii nagu oodatud, siis väljuge Rstudiost ja käivitage see uuesti ning kontrollige järgmist: Mine kohta: “C:/Users/Public/Documents/” (kopeeri see asukohareale) Kas on kataloog nimega “Rstudio_packages”. Kui seda ei ole, siis tee see. Jooksuta järgmist käsku. .libPaths(&quot;C:/Users/Public/Documents/Rstudio_packages&quot;) See määrab, et R otsib oma pakette just sealt kataloogist. Ja ka uued paketid installitakse sinna. Arvutiklassis on seda vaja, kuna sinu kasutajal ei ole arvuti juures kõiki õigusi. Juhul kui paketid olid varem installitud mujale, ei pruugi R neid enam üles leida ning vastavalt proovib neid sinna installida. Isiklikul arvutil seda tõenäoliselt ei ole vaja teha ning kui ligipääsuprobleeme pole, ärge seda käsku käivitage. Pärast selle määramist proovi installida tidyverse paketti uuesti. Uue asukohaga peaks installimine töötama ja paketi saab siis sisse lugeda. 4.2 R ja andmed Kuigi R-i võib kasutada ka lihtsateks numbriarvutusteks, siis üldiselt kasutatakse R-i tööks andmistekega. Andmestikud on enamasti salvestatud failidesse teatud formaadis (näiteks .csv, .tsv või .xls). Faili sisse lugemiseks on hulk erinevaid käske ja on vähe failitüüpe, millest R pakettide abiga jagu ei saa. Praegu on meil fail .tsv formaadis ja selle lugemiseks sobib meile käsk read_tsv(). read_tsv(&quot;data/eesti_top40/eesti_skyplus_top40_1994-2018.tsv&quot;) ## Parsed with column specification: ## cols( ## year = col_double(), ## rank = col_double(), ## votes = col_double(), ## artist = col_character(), ## song = col_character(), ## filename = col_character(), ## source = col_double(), ## lyrics = col_character(), ## language = col_character() ## ) ## # A tibble: 1,000 x 9 ## year rank votes artist song filename source lyrics language ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1994 1 NA Ummamuu… Kõnõtr… lyrics-umma… 1 &quot;:,:Välän kü… et ## 2 1994 2 NA Vennask… Pille-… lyrics-venn… 1 &quot;Taevas sine… et ## 3 1994 3 NA Jam See 5 lyrics-jam-… 1 &quot;See viis ha… et ## 4 1994 4 NA The Tub… Lillek… lyrics-the_… 1 &quot;Tüdruk vaat… et ## 5 1994 5 NA The Tub… Põhjam… lyrics-the_… 1 &quot;Kui käes on… et ## 6 1994 6 NA Jam Su Jär… lyrics-jam-… 1 &quot;Enne sind e… et ## 7 1994 7 NA 2 Quick… Olen L… lyrics-2_qu… 1 &quot;1. PÕHJUST … et ## 8 1994 8 NA Termina… Torm lyrics-term… 1 &quot;Olen tulnud… et ## 9 1994 9 NA 2 Quick… Sinu J… lyrics-2_qu… 1 &quot;1. EKSISIN … et ## 10 1994 10 NA D-Gän Seib lyrics-d-ga… 1 &quot;ELASID KOOS… et ## # … with 990 more rows Siit saime kaks väljatrükki. Esiteks tabeli enda kohta - read_tsv() ütleb, mis tüüpi andmetulpasid ta failist leidis. Siin antud juhul col_character() ehk tekstitulp ja col_double() ehk numbritulp. Oodatavat tüüpi saab ka lugemisel ise määrata. Ja teise asjana trükkis ta välja andmestiku enda, kus näeme, et andmed näevad välja, nagu oodata. Andmestiku salvestamiseks kasutame tuttavat noole &lt;- tähist. Siis on meil edaspidi andmestik kättesaadav muutuja edetabel all. edetabel &lt;- read_tsv(&quot;data/eesti_top40/eesti_skyplus_top40_1994-2018.tsv&quot;) ## Parsed with column specification: ## cols( ## year = col_double(), ## rank = col_double(), ## votes = col_double(), ## artist = col_character(), ## song = col_character(), ## filename = col_character(), ## source = col_double(), ## lyrics = col_character(), ## language = col_character() ## ) RStudios näete nüüd “environment” väljal, paremal ülal, et sinna on ilmunud sektsioon ‘data’ ning selle alla muutuja ’edetabel, kus on 1000 vaatlust ja 9 muutujat ehk 1000 rida ja 9 tulpa. Kui vajutate RStudios hiirega selle peale, avaneb see tabelina ülevaatuseks. Skriptiaknas, vaskul ülal, on nüüd uus sälk andmetele ning tagasi koodifaili saab vajutades koodifaili sälgule. (Selleks saab kasutada ka Ctrl+Tab ja Shift+Ctrl+Tab). Muu hulgas näete, et konsoolis jooksis uus käsk View(edetabel) View käsk näitab andmemuutuja sisu eraldi aknas. Proovi kirjutada konsooli sama käsk. View(edetabel) Ülevaatest on näha, et tabelis on järgmised tulbad. year - edetabeli aasta rank - koht edetabelis votes - häälte arv (kui on) artist - esineja song - loo pealkiri filename - faili nimi hoidlas source - sõnade allikas (1 - Sasslantis, 2 - muu) lyrics - laulusõnad language - keel (et - eesti, en - inglise) 4.3 Tidy andmestruktuurid Tidy ehk puhtad andmestruktuurid on kujunenud välja andmeanalüütikute vajadustest. Nimelt taipasid mõned neist, et kui andmestikke salvestatakse pidevalt väga erinevatel kujudel - igaüks mõtleb välja oma viisi - siis andmeanalüüsi jaoks on hea kui nad on suhteliselt samas formaadis ja ehk mida lihtsam seda parem. Tidy andmeloogika on võtnu omaks põhimõtte, et iga andmepunkti kohta võiks olla üks rida ja iga mõõdiku kohta üks tulp. Vastavalt sellele, mida me täpselt tahame teada saada võib erineda see, mis on meie andmepunkt. Andmepunktiks võiks olla näiteks majandusnäitajate Harju keskmine 1990ndate jooksul või siis Eesti riigi koondnäitaja 2019 aasta esimeses kvartalis. Meid võib huvitada üks tekst, üks lause või üks sõna. Tidy andmeloogika järgi püütakse siis andmestik ümber kujundada selliselt, et ükskõik mida me teada tahame oleks sel sama struktuur Iga rida on üks vaatlus (selle kohta, mida me tahame vaadelda). Iga tulp on üks vaatluse omadus või omadustekomplekt. Illustratsioon sellest on juhendis all. Kui seda vaadata, võiks mõelda, et kuidas saaks üldse teisiti. Aga andmestikke on koostatud ja koostatakse pidevalt väga erinevates viisides, mis toimivad ehk ühe koostaja või sisestaja jaoks, aga ei pruugi tunduda teistele sama head. Tidy andmeloogika üritab pakkuda lihtsaimat reeglit, mille järgi orienteeruda. 4.4 Tidyverse andmetöötlus Tidyverse üritab leida ühise aluse ka andmetöötlusele. Eelkõige üritab tidyverse andmetöötluse jaotada selgelt järjestikku operatsioonidest ning järgida literate programming loogikat. Selle loogika järgi peaks masinale mõeldud kood olema lihtsalt ja selgelt loetav ka inimese jaoks. Tidyverse püüab ühtse käskude grammatika järgi aidata nii algajal oskusi omandada kui panna andmeid omavahel ühtima. Kuigi tidyverse kood püüab hoida lihtsat ja arusaadavat kuju, ei tähenda, et selle võimekus oleks piiratud. Peaaegu iga käsku on võimalik kirjutada ka tidyverse viisil. Tidyverse stiilis töötlusel näeb üks R-i käskudekomplekt välja järgmine. andmed %&gt;% protsess1() %&gt;% protsess2() Alustuseks on R-is sisse loetud andmed, siis nendega tehakse protsess1() ja siis protsess2(). Selle järjestuse juhendamiseks kasutab tidyverse toru %&gt;% funktsiooni mis suunab andmestiku protsessi ning selle protsessi tulemuse omakorda protsessi. Üks viis selles mõelda on nii, et muutujad on nimisõnad ja protsessid on tegusõnad ja kokkuvõttes huvitab meid, mis algsest nimisõnalisest tegelasest saab. Andmete töötlemiseks kasutame niisiis rea lõpus toru %&gt;% funktsiooni. Selle võib trükkida välja või võib vajutada korraga ka Ctrl+Shift+M mis asetab %&gt;% torumärgi teksti. Töötluse näites, kui me trükime edetabel %&gt;% names(), saame andmestiku kõikide tulpade nimed jadana. Proovi järgi: mine reale ja vajuta Ctrl+Enter. R teab, et %&gt;% torumärgile peaks järgnema veel käsk ja ta loeb seda edasi, isegi kui selleks peab minema järgmisele reale. Seda ära kasutades ning töötluse loetavuse nimel paigutatakse tidyverse stiilis iga käsk eraldi reale. Kui koostad keerulise funktsiooni, võid küll sellest ise kergesti aru saada, aga juhuslikule lugejale on palju kergem kui kõik operatsioonid on selgelt eraldatud. edetabel %&gt;% names() ## [1] &quot;year&quot; &quot;rank&quot; &quot;votes&quot; &quot;artist&quot; &quot;song&quot; &quot;filename&quot; &quot;source&quot; ## [8] &quot;lyrics&quot; &quot;language&quot; 4.5 filter(), select(), unique(), sample_n() Teades põhiprintsiipi lähebki vaja hakata operatsioone omavahel kombineerima ja järjestama, et saada andmestikust kätte täpselt seda informatsiooni, mida vaja. Võtame alustuseks neli käsku, mis on mõeldud tabeli osade valimiseks ja loendamiseks. Nimelt filter(), count(), select(), unique(). %&gt;% - viib andmed järgmisesse protsessi select() valib tunnused andmestikust filter() viib andmestiku läbi filtri/sõela unique() - võtab tabelist ainult unikaalsed read sample_n() - võtab ettemääratud suurusega hulga ridu tabelist Käsk select() valib andmestikust teatud tulbad. Seda võib teha nime kaudu või mingil muul alusel, nii võib saada ühe või mitu tulpa. Kirjutades select(year) toru järgi valime siis year-nimelise tulba, ehk tulba kus on aastaarvud. edetabel %&gt;% select(year) ## # A tibble: 1,000 x 1 ## year ## &lt;dbl&gt; ## 1 1994 ## 2 1994 ## 3 1994 ## 4 1994 ## 5 1994 ## 6 1994 ## 7 1994 ## 8 1994 ## 9 1994 ## 10 1994 ## # … with 990 more rows Käsk unique() valib andmestikust kõik read, mis on unikaalse. Näiteks valides unikaalsed read aasta tulbast saame jada 25-st erinevast aastast, mis on andmestikus. edetabel %&gt;% select(year) %&gt;% unique() ## # A tibble: 25 x 1 ## year ## &lt;dbl&gt; ## 1 1994 ## 2 1995 ## 3 1996 ## 4 1997 ## 5 1998 ## 6 1999 ## 7 2000 ## 8 2001 ## 9 2002 ## 10 2003 ## # … with 15 more rows Kui me võtame unikaalsed read tervest andmestikust, saame vastuseks sama andmestiku, kuna kõik read on seal unikaalsed. edetabel %&gt;% unique() ## # A tibble: 1,000 x 9 ## year rank votes artist song filename source lyrics language ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1994 1 NA Ummamuu… Kõnõtr… lyrics-umma… 1 &quot;:,:Välän kü… et ## 2 1994 2 NA Vennask… Pille-… lyrics-venn… 1 &quot;Taevas sine… et ## 3 1994 3 NA Jam See 5 lyrics-jam-… 1 &quot;See viis ha… et ## 4 1994 4 NA The Tub… Lillek… lyrics-the_… 1 &quot;Tüdruk vaat… et ## 5 1994 5 NA The Tub… Põhjam… lyrics-the_… 1 &quot;Kui käes on… et ## 6 1994 6 NA Jam Su Jär… lyrics-jam-… 1 &quot;Enne sind e… et ## 7 1994 7 NA 2 Quick… Olen L… lyrics-2_qu… 1 &quot;1. PÕHJUST … et ## 8 1994 8 NA Termina… Torm lyrics-term… 1 &quot;Olen tulnud… et ## 9 1994 9 NA 2 Quick… Sinu J… lyrics-2_qu… 1 &quot;1. EKSISIN … et ## 10 1994 10 NA D-Gän Seib lyrics-d-ga… 1 &quot;ELASID KOOS… et ## # … with 990 more rows Kui me soovime kätte saada mingeid konkreetseid ridu, mis vastavad teatud tunnustele, võime andmestiku läbi lasta filter() käsust. Sellisel juhul peame filter() sisse kirjutama tingimuse, mis peab vastama kas tõele või väärale ehk see peab kontrollima võrdsust nagu eelmises tükis sai näidatud. Näiteks, kui me tahame leida kõiki Smilersi lugusid võime me otsida välja kõik read, kus tunnus artist on sama kui tekst “Smilers”. Tähtis on selle päringu juures, et see tunnus peab olema täpselt sama. Pane tähele ka, et siin on siis kasutatud topeltvõrdumärki ==. edetabel %&gt;% filter(artist==&quot;Smilers&quot;) ## # A tibble: 47 x 9 ## year rank votes artist song filename source lyrics language ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1996 4 1192 Smilers Tahan … lyrics-smi… 1 hellalt luban … et ## 2 1997 23 216 Smilers Viis K… lyrics-smi… 1 tunne on hea j… et ## 3 1997 30 146 Smilers Lähme … lyrics-smi… 1 sa väljakutsuv… et ## 4 1998 1 1216 Smilers Tantsi… lyrics-smi… 1 Kuu on täis is… et ## 5 1998 12 267 Smilers Mõtlen… lyrics-smi… 1 täna ärkasin v… et ## 6 1998 18 169 Smilers Ära Vi… lyrics-smi… 1 Tahan olla su … et ## 7 1998 21 133 Smilers Mõistu… lyrics-smi… 1 suhe meil suju… et ## 8 1998 22 129 Smilers Nagu H… lyrics-smi… 1 Ma tean et see… et ## 9 1998 28 101 Smilers Aega P… lyrics-smi… 1 ma ennast jäll… et ## 10 1998 29 100 Smilers Sinu K… lyrics-smi… 1 Oma kolmteist … et ## # … with 37 more rows Kui me kasutame nime smilers väikse algustähega, siis me neid tulemusi ei leia, kuna tulemus pole täpselt sama. Kui me suurest või väiksest algustähest ei hooli, võime muuta terve tunnuse selliseks, et tal on väike algustäht või kasutada regulaaravaldisi vaste leidmiseks. Sellest on näiteid hiljem. edetabel %&gt;% filter(artist==&quot;smilers&quot;) ## # A tibble: 0 x 9 ## # … with 9 variables: year &lt;dbl&gt;, rank &lt;dbl&gt;, votes &lt;dbl&gt;, artist &lt;chr&gt;, ## # song &lt;chr&gt;, filename &lt;chr&gt;, source &lt;dbl&gt;, lyrics &lt;chr&gt;, language &lt;chr&gt; Proovi nüüd ise leida kõik Ummamuudu lood, kirjutades sarnane koodijupp siia alla. #--------------------------------------------- #--------------------------------------------- Me võime ka kombineerida omavahel filter() ja select(), et saata väiksema ülevaate tabelist. Näiteks võime võtta välja kõikide Smilersi lugude aastad ja pealkirjad. edetabel%&gt;% filter(artist==&quot;Smilers&quot;) %&gt;% select(year,song) ## # A tibble: 47 x 2 ## year song ## &lt;dbl&gt; &lt;chr&gt; ## 1 1996 Tahan Sind ## 2 1997 Viis Kasti Õlut ## 3 1997 Lähme sõidame ## 4 1998 Tantsin Sinuga Taevas ## 5 1998 Mõtlen Sinust ## 6 1998 Ära Viska Mind Ära ## 7 1998 Mõistus On Kadunud ## 8 1998 Nagu Hunt ## 9 1998 Aega Parajaks Teen ## 10 1998 Sinu Küljes Kinni ## # … with 37 more rows Neid käske võib ka korduvalt lisada. Näiteks saame võtta kõigepealt Smilersi lood ja siis nende seast välja ainult lood, mis olid edetabelis aastal 1998. edetabel%&gt;% filter(artist==&quot;Smilers&quot;) %&gt;% select(year,song) %&gt;% filter(year==1998) ## # A tibble: 7 x 2 ## year song ## &lt;dbl&gt; &lt;chr&gt; ## 1 1998 Tantsin Sinuga Taevas ## 2 1998 Mõtlen Sinust ## 3 1998 Ära Viska Mind Ära ## 4 1998 Mõistus On Kadunud ## 5 1998 Nagu Hunt ## 6 1998 Aega Parajaks Teen ## 7 1998 Sinu Küljes Kinni Või näiteks 2000 ja 2008 aasta vahel. edetabel%&gt;% filter(artist==&quot;Smilers&quot;) %&gt;% select(year,song) %&gt;% filter(year&gt;2000) %&gt;% filter(year&lt;2008) ## # A tibble: 23 x 2 ## year song ## &lt;dbl&gt; &lt;chr&gt; ## 1 2001 Mina, Pets, Margus &amp; Priit ## 2 2001 Jalgpall on parem kui seks ## 3 2001 Kalamaja cowboy ## 4 2001 Upun su silmadesse ## 5 2001 Mõtlen sinust ## 6 2001 Meteoriitide sajus ## 7 2002 Meteoriitide sajus ## 8 2002 Jalgpall on parem kui sex ## 9 2002 Kvaliteetaeg ## 10 2003 Käime katuseid mööda ## # … with 13 more rows Soovi korral võib mitu filtrit ka ühendada ühte käsku. Sel juhul tuleb kasutada &amp; märki nende ühendamiseks. edetabel%&gt;% filter(artist==&quot;Smilers&quot;) %&gt;% select(year,song) %&gt;% filter(year&gt;2000 &amp; year&lt;2008) ## # A tibble: 23 x 2 ## year song ## &lt;dbl&gt; &lt;chr&gt; ## 1 2001 Mina, Pets, Margus &amp; Priit ## 2 2001 Jalgpall on parem kui seks ## 3 2001 Kalamaja cowboy ## 4 2001 Upun su silmadesse ## 5 2001 Mõtlen sinust ## 6 2001 Meteoriitide sajus ## 7 2002 Meteoriitide sajus ## 8 2002 Jalgpall on parem kui sex ## 9 2002 Kvaliteetaeg ## 10 2003 Käime katuseid mööda ## # … with 13 more rows Me võime ka kõik filtrid panna kokku ühte käsku edetabel%&gt;% filter(artist==&quot;Smilers&quot; &amp; year&gt;2000 &amp; year&lt;2008) %&gt;% select(year,song) ## # A tibble: 23 x 2 ## year song ## &lt;dbl&gt; &lt;chr&gt; ## 1 2001 Mina, Pets, Margus &amp; Priit ## 2 2001 Jalgpall on parem kui seks ## 3 2001 Kalamaja cowboy ## 4 2001 Upun su silmadesse ## 5 2001 Mõtlen sinust ## 6 2001 Meteoriitide sajus ## 7 2002 Meteoriitide sajus ## 8 2002 Jalgpall on parem kui sex ## 9 2002 Kvaliteetaeg ## 10 2003 Käime katuseid mööda ## # … with 13 more rows Filtrite puhul võime kasutada ka või | märki. Näiteks võime sama käsku väljedada ka mitte piirkondadega, vaid andes ette võimalikud variandi võiga. edetabel%&gt;% filter(artist==&quot;Smilers&quot;) %&gt;% select(year,song) %&gt;% filter(year==2001 | year==2002 | year==2003 | year==2004 | year==2005 | year==2006 | year==2007) ## # A tibble: 23 x 2 ## year song ## &lt;dbl&gt; &lt;chr&gt; ## 1 2001 Mina, Pets, Margus &amp; Priit ## 2 2001 Jalgpall on parem kui seks ## 3 2001 Kalamaja cowboy ## 4 2001 Upun su silmadesse ## 5 2001 Mõtlen sinust ## 6 2001 Meteoriitide sajus ## 7 2002 Meteoriitide sajus ## 8 2002 Jalgpall on parem kui sex ## 9 2002 Kvaliteetaeg ## 10 2003 Käime katuseid mööda ## # … with 13 more rows Viimaks võime kasutada ka eelpool mainitud %in% käsku, mis kontrollib väärtuse olemasolu jadas. edetabel%&gt;% filter(artist==&quot;Smilers&quot;) %&gt;% select(year,song) %&gt;% filter(year %in% 2001:2007) ## # A tibble: 23 x 2 ## year song ## &lt;dbl&gt; &lt;chr&gt; ## 1 2001 Mina, Pets, Margus &amp; Priit ## 2 2001 Jalgpall on parem kui seks ## 3 2001 Kalamaja cowboy ## 4 2001 Upun su silmadesse ## 5 2001 Mõtlen sinust ## 6 2001 Meteoriitide sajus ## 7 2002 Meteoriitide sajus ## 8 2002 Jalgpall on parem kui sex ## 9 2002 Kvaliteetaeg ## 10 2003 Käime katuseid mööda ## # … with 13 more rows Proovi nüüd kätte saada kõik lood mis olnud smilersil küll esikümnes, aga mitte esiviies. (Vihje: vaata tulpa rank.) #--------------------------------------------- #--------------------------------------------- Proovi leida ka kõik lood, mis olid 1990ndatel tabelis inglise keeles. (Vihje: vaata tulpa language.) #--------------------------------------------- #--------------------------------------------- Tihti soovime näha või kasutada mitte tervet andmestikku, vaid juhuslikku osa sellest. Lihtsa valimi tekitamiseks on ka olemas omaette käsk. sample_n() võtab hulgast välja juhusliku n rida, kus n-i väärtuse me määrame sulgude sees. Teeme väikse katse iseendaga, trükime välja 10 lugu aastast 1997 ja 10 lugu aastast 2017. Vaatame ja võrdleme. Mitu lugu ja esinejat tunneme ära rohkem kui 20 aastat tagasi, mitu esinejat tunneme ära hiljutisest edetabelist. Tulemused ütlevad siinkohal küll rohkem lugeja enda kohta kui andmestiku kohta. edetabel %&gt;% filter(year==1997) %&gt;% sample_n(10) ## # A tibble: 10 x 9 ## year rank votes artist song filename source lyrics language ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1997 11 347 Black V… Öö Silm… lyrics-blac… 1 &quot;Tunnen süd… et ## 2 1997 17 295 Maarja Keelatu… lyrics-maar… 1 &quot;Miks aina … et ## 3 1997 39 78 Termina… Kristal… lyrics-term… 1 &quot;Ma tean et… et ## 4 1997 16 296 Bläck R… Itimees lyrics-blac… 1 &quot;Itimees Rä… et ## 5 1997 21 234 2 Quick… Oled Ku… lyrics-2_qu… 1 &quot;Ma nägin p… et ## 6 1997 8 707 Code One Nüüd Võ… lyrics-code… 1 &quot;Ühel hetke… et ## 7 1997 27 163 Folkmill Käib Sa… lyrics-folk… 1 &quot;sõidab tas… et ## 8 1997 22 231 Maria La-La-La &lt;NA&gt; NA &lt;NA&gt; &lt;NA&gt; ## 9 1997 24 197 Me, mys… I Don&#39;t… &lt;NA&gt; NA &lt;NA&gt; &lt;NA&gt; ## 10 1997 34 120 The Tub… Okkalin… lyrics-the_… 1 &quot;Üks mis ki… et edetabel %&gt;% filter(year==2017) %&gt;% sample_n(10) ## # A tibble: 10 x 9 ## year rank votes artist song filename source lyrics language ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2017 4 512 Respekt Peapeal lyrics-res… 1 Meid nähti se… et ## 2 2017 18 137 Koit To… Verona lyrics-koi… 1 Sleeping all … en ## 3 2017 21 105 Ott Lep… Siin m… lyrics-ott… 1 Käes on aeg, … et ## 4 2017 20 118 Grete P… Wasted… &lt;NA&gt; NA &lt;NA&gt; &lt;NA&gt; ## 5 2017 28 83 Karl-Er… Ei &lt;NA&gt; NA &lt;NA&gt; &lt;NA&gt; ## 6 2017 37 55 DND Kontse… lyrics-dnd… 1 Ma nägin su s… et ## 7 2017 35 57 Iiris Strang… lyrics-iir… 1 Come on lift … en ## 8 2017 3 575 Naised … Aasta … lyrics-nai… 1 Aasta emaks e… et ## 9 2017 29 82 Miljard… Vilkuv… lyrics-mil… 1 kasvab lapsi … et ## 10 2017 8 284 Shanon NaNaNa… &lt;NA&gt; NA &lt;NA&gt; &lt;NA&gt; Proovi ise! Võta andmestikust välja 10 juhuslikku esikohalugu. Vaata, kas neid tead? #--------------------------------------------- #--------------------------------------------- 4.6 count(), group_by() Et meil on tegemist edetabeliga, siis püüame kõigepealt selle tippudest aru saada. Selle jaoks on tidyverse andmetöötluses olemas eraldi käsk count(). Kasulik on siin vaadata ka käsku group_by(). count() - loeb esinemiste arvu group_by() - grupeerib tabeli mingi tunnuse alusel. Et saada tabelist ja selle sisust paremat ülevaadet, on võimalik selles esinevaid väärtusi ka loendada. Näiteks vaatame artistide esinemiskordasid top 40s. Esinemiskordade arv sai salvestatud tulpa n. edetabel %&gt;% count(artist) ## # A tibble: 348 x 2 ## artist n ## &lt;chr&gt; &lt;int&gt; ## 1 2 Quick Start 24 ## 2 2 Quick Start &amp; Hedvig Hanson 1 ## 3 4 Ever 1 ## 4 5miinust 1 ## 5 5MIINUST 1 ## 6 5MIINUST x Sass Henno 1 ## 7 6-Pack 1 ## 8 A-Rühm 7 ## 9 Agape 1 ## 10 Agent M 1 ## # … with 338 more rows Käskudele saab ka lisada parameetreid. Need on eraldatud sisendist komaga. Näiteks count() puhul on võimalik lisada parameeter sort=T, mis järjestab loenduse tulemused suurest väiksemani. Täpsemalt ütleme siis käsule, et lugegu sort väärtuseks T, kui vaikimisi võib ta olla midagi muud. Nii saame kätte artistid, kes said kõige enam tabelisse. edetabel %&gt;% count(artist,sort=T) ## # A tibble: 348 x 2 ## artist n ## &lt;chr&gt; &lt;int&gt; ## 1 Smilers 47 ## 2 Terminaator 46 ## 3 2 Quick Start 24 ## 4 Ines 21 ## 5 Tanel Padar &amp; The Sun 16 ## 6 Ott Lepland 15 ## 7 Caater 14 ## 8 Põhja-Tallinn 14 ## 9 Jam 12 ## 10 Laura 12 ## # … with 338 more rows Selliseid lisavõimalusi leiab iga käsu juhendist, mida saab vaadata lisades käsu ette küsimärgi. Näiteks ?count. Proovi seda! All vasakul avaneb seepeale juhend Help aknas. Failivaatele tagasi saab vajutades sälgule Files. ?count Niiviisi võime loendada ka ükskõik mida. Näiteks, palju oli lugusid eri keeltes. edetabel %&gt;% count(language,sort=T) ## # A tibble: 6 x 2 ## language n ## &lt;chr&gt; &lt;int&gt; ## 1 et 686 ## 2 &lt;NA&gt; 178 ## 3 en 133 ## 4 es 1 ## 5 fr 1 ## 6 it 1 Näeme et 686 lugu on eestikeelset, 133 lugu on ingliskeelset ja 178 loo puhul ei tea me täpselt, mis keeles need on. See on andmestiku eripära, enamikes andmestikes on puuduvaid andmeid. Andmete puuduvuse kontrollimine ei käi võrdusmärkidega, aga funktsiooniga is.na(). Näiteks filter(is.na(language)) annab meile kõik lood, kus on keel puudu. edetabel %&gt;% filter(is.na(language)) ## # A tibble: 178 x 9 ## year rank votes artist song filename source lyrics language ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1994 13 NA Nancy Mul luba loo… &lt;NA&gt; NA &lt;NA&gt; &lt;NA&gt; ## 2 1994 16 NA Kuldne Trio Ütlen Sulle A &lt;NA&gt; NA &lt;NA&gt; &lt;NA&gt; ## 3 1994 20 NA Kuldne Trio Ulla-Tralla &lt;NA&gt; NA &lt;NA&gt; &lt;NA&gt; ## 4 1994 27 NA Evelin Samuel Vari Ja Roos &lt;NA&gt; NA &lt;NA&gt; &lt;NA&gt; ## 5 1994 29 NA Jam Öised Teed &lt;NA&gt; NA &lt;NA&gt; &lt;NA&gt; ## 6 1994 32 NA Kuldne Trio Vana roosa &lt;NA&gt; NA &lt;NA&gt; &lt;NA&gt; ## 7 1994 36 NA Evelin Samuel Flight &lt;NA&gt; NA &lt;NA&gt; &lt;NA&gt; ## 8 1994 37 NA MC Leo Keegi Veel &lt;NA&gt; NA &lt;NA&gt; &lt;NA&gt; ## 9 1994 39 NA Double + Sel Tänaval &lt;NA&gt; NA &lt;NA&gt; &lt;NA&gt; ## 10 1994 40 NA Agape Grungemees &lt;NA&gt; NA &lt;NA&gt; &lt;NA&gt; ## # … with 168 more rows Võime salvestada tulemuse, et seda lähemalt vaadata. puuduvad &lt;- edetabel %&gt;% filter(is.na(language)) Ja vaatame talle sisse. View(puuduvad) Selgub, et keel on puudu, sellepärast et lauludel ei ole sõnu lisatud. Sellega tuleb andmestikes arvestada. Samas artistide või laulupealkirjade loendamiseks sobivad need siiski. Katsetame veel count() funktsiooni. Võime näiteks kokku lugeda, mitu korda esineb iga aastat, ehk et mitu lugu on igas aastas. Näeme, et kenasti 40 lugu aastas on top 40-s. edetabel %&gt;% count(year) ## # A tibble: 25 x 2 ## year n ## &lt;dbl&gt; &lt;int&gt; ## 1 1994 40 ## 2 1995 40 ## 3 1996 40 ## 4 1997 40 ## 5 1998 40 ## 6 1999 40 ## 7 2000 40 ## 8 2001 40 ## 9 2002 40 ## 10 2003 40 ## # … with 15 more rows Me võime loendada mitut gruppi korraga. Näiteks loendades, mitu korda on artist ja aastaarv koos, saame teada mitu lugu artistilt sel aastal edetabelis oli. edetabel %&gt;% count(artist,year,sort =T) ## # A tibble: 687 x 3 ## artist year n ## &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Jam 1994 7 ## 2 Smilers 1998 7 ## 3 Smilers 2001 6 ## 4 Tanel Padar @ The Sun 2007 6 ## 5 Tanel Padar &amp; The Sun 2006 6 ## 6 Terminaator 2003 6 ## 7 2 Quick Start 1994 5 ## 8 Ines 2005 5 ## 9 Nancy 1995 5 ## 10 Nexus 2005 5 ## # … with 677 more rows Me võime ka loendada neid gruppe korduvalt. Näiteks loendades seal veelkord aastaarvu, saame teada, mitu erinevat artisti oli konkreetsel aastal edetabelis. edetabel %&gt;% count(artist,year) %&gt;% count(year) ## # A tibble: 25 x 2 ## year n ## &lt;dbl&gt; &lt;int&gt; ## 1 1994 20 ## 2 1995 25 ## 3 1996 25 ## 4 1997 23 ## 5 1998 23 ## 6 1999 26 ## 7 2000 31 ## 8 2001 25 ## 9 2002 29 ## 10 2003 20 ## # … with 15 more rows Võime seda kombineerida ka filtritega. Näiteks võime vaadata iga aasta kohta, mitu eesti popmuusika lipulaevade lugu edetabelis oli. edetabel %&gt;% filter(artist==&quot;Smilers&quot;) %&gt;% count(year) ## # A tibble: 19 x 2 ## year n ## &lt;dbl&gt; &lt;int&gt; ## 1 1996 1 ## 2 1997 2 ## 3 1998 7 ## 4 1999 3 ## 5 2000 1 ## 6 2001 6 ## 7 2002 3 ## 8 2003 3 ## 9 2004 4 ## 10 2005 3 ## 11 2006 1 ## 12 2007 3 ## 13 2008 1 ## 14 2009 2 ## 15 2011 2 ## 16 2013 2 ## 17 2014 1 ## 18 2015 1 ## 19 2016 1 edetabel %&gt;% filter(artist==&quot;Terminaator&quot;) %&gt;% count(year) ## # A tibble: 17 x 2 ## year n ## &lt;dbl&gt; &lt;int&gt; ## 1 1994 2 ## 2 1995 3 ## 3 1996 4 ## 4 1997 4 ## 5 1998 4 ## 6 1999 1 ## 7 2000 3 ## 8 2001 5 ## 9 2002 1 ## 10 2003 6 ## 11 2004 1 ## 12 2005 1 ## 13 2006 4 ## 14 2007 3 ## 15 2008 1 ## 16 2009 2 ## 17 2017 1 Nad mõlemad alustasid 1990ndate keskel, aga on hitte teinud veel 2016 ja 2017 aastail. Proovi veel ühe enda valitud artistiga, mis aastail kui palju lugusid neil on olnud. #--------------------------------------------- #--------------------------------------------- Proovi ka teada saada, mitu lugu oli mis keeles 1994 aastal ja 2014 aastal. #--------------------------------------------- #--------------------------------------------- Võib märgata, et kui me loendame tunnuste väärtuseid tabelis, siis me jaotame oma andmestiku gruppideks ja ütleme kui palju seal väärtuseid on. Selleks on olemas R-is ka üldisem funktsioon group_by(). Kui me loendasime artiste aasta peale kasutades count() käsus kaht tunnust, nagu all, siis võime seda teisiti sõnastada ka, et me grupeerisime andmestiku artistide kaupa ja loendasime esinemisi aastas. edetabel %&gt;% count(artist,year,sort =T) ## # A tibble: 687 x 3 ## artist year n ## &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Jam 1994 7 ## 2 Smilers 1998 7 ## 3 Smilers 2001 6 ## 4 Tanel Padar @ The Sun 2007 6 ## 5 Tanel Padar &amp; The Sun 2006 6 ## 6 Terminaator 2003 6 ## 7 2 Quick Start 1994 5 ## 8 Ines 2005 5 ## 9 Nancy 1995 5 ## 10 Nexus 2005 5 ## # … with 677 more rows edetabel %&gt;% group_by(artist) %&gt;% count(year,sort =T) ## # A tibble: 687 x 3 ## # Groups: artist [348] ## artist year n ## &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Jam 1994 7 ## 2 Smilers 1998 7 ## 3 Smilers 2001 6 ## 4 Tanel Padar @ The Sun 2007 6 ## 5 Tanel Padar &amp; The Sun 2006 6 ## 6 Terminaator 2003 6 ## 7 2 Quick Start 1994 5 ## 8 Ines 2005 5 ## 9 Nancy 1995 5 ## 10 Nexus 2005 5 ## # … with 677 more rows Kui count() on spetsiaalne käsk loendamiseks, siis group_by() on laiema kasutusega käsk, kuidas grupeerida ka teisi operatsioone. Me võime grupeerimist ka filtritega. Näiteks võime võrrelda, kui palju oli lugusid eri keeltes 1990ndate aastate keskel ja 2010ndate aastate keskel. edetabel %&gt;% filter(year%in%c(1994,2014)) %&gt;% count(language,year) ## # A tibble: 6 x 3 ## language year n ## &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 en 1994 2 ## 2 en 2014 8 ## 3 et 1994 28 ## 4 et 2014 28 ## 5 &lt;NA&gt; 1994 10 ## 6 &lt;NA&gt; 2014 4 Ja sama võrdlus group_by() funktsiooniga. edetabel %&gt;% filter(year%in%c(1994,2014)) %&gt;% group_by(year) %&gt;% count(language) ## # A tibble: 6 x 3 ## # Groups: year [2] ## year language n ## &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; ## 1 1994 en 2 ## 2 1994 et 28 ## 3 1994 &lt;NA&gt; 10 ## 4 2014 en 8 ## 5 2014 et 28 ## 6 2014 &lt;NA&gt; 4 Proovi ise! Grupeeri andmestik lugude kaupa ning vaata, mitmel aastal nad tabelisse said. #--------------------------------------------- #--------------------------------------------- 4.7 arrange(), mutate(), row_number(), summarise(), n() R-i tõeline väärtus aga tuleb ette kui see, mida me teada tahame, ei ole lihtsalt andmestikus sees, vaid see tuleb sealt alles välja arvutada. Andmestiku muutmiseks on lihtsamad käsud arrange(), mutate(), row_number(), summarise(), n(). arrange() - muudab tabeli elementide järjekorda, vähim väärtus ees arrange(desc()) - muudab tabeli elementide järjekorda, suurim väärtus ees mutate() - lisab tabelile uue tulba row_number() - väljastab rea järjekorranumbri summarise() - teeb tabelist kokkuvõtte n() - loendab kokku, mitu tunnust grupis on arrange() käsk järjestab andmestiku mingi tunnuse järgi. Näiteks järjestame tabeli nii, et tipus on kõik esikohad, järgnevad teised kohad ja nii edasi. edetabel %&gt;% arrange(rank) ## # A tibble: 1,000 x 9 ## year rank votes artist song filename source lyrics language ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1994 1 NA Ummamu… Kõnõtr… lyrics-umma… 1 &quot;:,:Välän kül… et ## 2 1995 1 1132 Termin… Juulik… lyrics-term… 1 &quot;Kõik ei ole … et ## 3 1996 1 1940 Best B4 Ma Arm… lyrics-best… 1 &quot;Nagu varju e… et ## 4 1997 1 1923 Black … 17 lyrics-blac… 1 &quot;On õhtu häma… et ## 5 1998 1 1216 Smilers Tantsi… lyrics-smil… 1 &quot;Kuu on täis … et ## 6 1999 1 1125 Caater Osi Ne… &lt;NA&gt; NA &lt;NA&gt; &lt;NA&gt; ## 7 2000 1 2097 Ines Once I… lyrics-ines… 1 &quot;I don&#39;t wish… en ## 8 2001 1 2149 2 Quic… Ühega … lyrics-2_qu… 1 &quot;Võin niimood… et ## 9 2002 1 1882 Termin… Romula lyrics-term… 1 &quot;Õhtu saabunu… et ## 10 2003 1 2262 Nexus Nii Ku… lyrics-nexu… 1 &quot;Üksikuna lei… et ## # … with 990 more rows Me võime järjestada ka mitme tunnuse alusel. Järjestame nad kõigepealt edetabelikoha järgi, aga lisame, et uuemad lood võiksid olla ees. Selle jaoks saame lisada lihtsalt komaga eraldatult uue tunnuse. desc() funktsioon pöörab tunnuse järjestuse ümber, nii et suurim väärtus on eespool edetabel %&gt;% arrange(rank, desc(year)) ## # A tibble: 1,000 x 9 ## year rank votes artist song filename source lyrics language ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2018 1 877 Nublu Mina … lyrics-nubl… 1 Sest sa ei t… et ## 2 2017 1 845 Põhja-Ta… Alati… lyrics-pohj… 1 Pole ma eale… et ## 3 2016 1 837 Shanon Suvi … lyrics-shan… 1 Kuumus tõsta… et ## 4 2015 1 1609 Karl-Eri… Segas… lyrics-karl… 1 Me vahel sõd… et ## 5 2014 1 702 Curly St… Kauge… lyrics-curl… 1 Kauges külas… et ## 6 2013 1 796 Smilers Mojito lyrics-smil… 1 Kahte pikka … et ## 7 2012 1 1385 Põhja-Ta… Meil … lyrics-pohj… 1 Refrään (2x)… et ## 8 2011 1 1166 Ewert An… Good … lyrics-ewer… 1 Here is a st… en ## 9 2010 1 1583 Koit Too… Mäles… lyrics-koit… 1 leidsin saht… et ## 10 2009 1 1296 Koit Too… Kauge… lyrics-koit… 1 Olen tagasi … et ## # … with 990 more rows Samuti ei pruugi järjestada ainult numbrite alusel, vaid saab järjestada ka tekstijuppe tähestiku alusel. Näiteks saame asetada lood tähestiku järjekorda. Seejuures numbrid ja sümbolid on sellistes järjestustes enamasti paigutatud tähtedest ettepoole. edetabel %&gt;% arrange(song) ## # A tibble: 1,000 x 9 ## year rank votes artist song filename source lyrics language ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2018 24 124 Frankie… (Can&#39;t … lyrics-fran… 1 &quot;You were m… en ## 2 2011 6 716 Ewert A… (In The… lyrics-ewer… 1 &quot;shake me u… en ## 3 2000 13 261 Vennask… 101.Kil… lyrics-venn… 1 &quot;Käisid tüd… et ## 4 2013 31 88 Metsaku… 11 &lt;NA&gt; NA &lt;NA&gt; &lt;NA&gt; ## 5 2017 30 77 Termina… 13 sammu lyrics-term… 1 &quot;Kord kokku… et ## 6 1997 9 446 Vennask… 15 lyrics-venn… 1 &quot;Kuigi juba… et ## 7 2005 26 447 Ines 15 maga… lyrics-ines… 1 &quot;iseendale … et ## 8 1997 1 1923 Black V… 17 lyrics-blac… 1 &quot;On õhtu hä… et ## 9 2003 7 780 Sõpruse… 1905 lyrics-sopr… 1 &quot;Vabrikute … et ## 10 2008 40 130 Mari-Le… 1987 lyrics-mari… 1 &quot;Ma pühin t… et ## # … with 990 more rows Kui me tahaksime kätte saada kõik kolmanda koha lood, võime kasutada käsku filter(). edetabel %&gt;% filter(rank==3) ## # A tibble: 25 x 9 ## year rank votes artist song filename source lyrics language ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1994 3 NA Jam See 5 lyrics-jam-… 1 See viis haar… et ## 2 1995 3 613 Ummamu… Tunnen… lyrics-umma… 1 Ma tunnen ära… et ## 3 1996 3 1393 Code O… On Kül… lyrics-code… 1 On küll hilja… et ## 4 1997 3 844 Mari L… Teine … lyrics-mari… 1 ref: miks mee… et ## 5 1998 3 NA 2 Quic… Teine … lyrics-2_qu… 1 Su pilk on tu… et ## 6 1999 3 958 2 Quic… C&#39;est … lyrics-2_qu… 1 Pilk peale jä… et ## 7 2000 3 960 Caater Dance … &lt;NA&gt; NA &lt;NA&gt; &lt;NA&gt; ## 8 2001 3 1160 Hannah Salaja lyrics-hann… 1 Salaja kuulas… et ## 9 2002 3 1258 Tanel … Unistus lyrics-tane… 1 Iga päevaga r… et ## 10 2003 3 1425 Smilers Käime … lyrics-smil… 1 Käime katusei… et ## # … with 15 more rows Kui me aga tahaksime kätte saada populaarsuselt kolmanda artisti, siis ei ole meil filtreerimiseks kohe alust. edetabel %&gt;% count(artist,sort=T) ## # A tibble: 348 x 2 ## artist n ## &lt;chr&gt; &lt;int&gt; ## 1 Smilers 47 ## 2 Terminaator 46 ## 3 2 Quick Start 24 ## 4 Ines 21 ## 5 Tanel Padar &amp; The Sun 16 ## 6 Ott Lepland 15 ## 7 Caater 14 ## 8 Põhja-Tallinn 14 ## 9 Jam 12 ## 10 Laura 12 ## # … with 338 more rows Me võiksime küll peale vaadata, et kolmanda koha artistil oli edetabelis laule täpselt 24 korda või rohkem kui 21 ja vähem kui 46 korda aga see lahendus toimib juhtumisi ainult selles andmestikus ja ainult praegu. Võimalik, et meil on näiteks artisti nimedes vigu ja lõplikud väärtused ei ole täpselt sellised. Et saada kätte kolmanda koha, peame lisama andmestikule uut informatsiooni, näiteks järjekorranumbri. Selleks on tidyverse pakettides käsk mutate(), mis muudab üht andmestiku tulpa. Kui anda sisendiks tulba nimi, mis veel ei eksisteeri, saab käsk selle lisada. Ja teine käsk, mida me saame siin kasutada on row_number(). See tekitab jada, mis algab ühest ja lõppeb rea pikkusega. Tulba lisamiseks märgime nii mutate(tulbanimi = sisend) ehk praegu mutate(rownr = row_number()). edetabel %&gt;% count(artist,sort=T) %&gt;% mutate(rownr = row_number()) ## # A tibble: 348 x 3 ## artist n rownr ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Smilers 47 1 ## 2 Terminaator 46 2 ## 3 2 Quick Start 24 3 ## 4 Ines 21 4 ## 5 Tanel Padar &amp; The Sun 16 5 ## 6 Ott Lepland 15 6 ## 7 Caater 14 7 ## 8 Põhja-Tallinn 14 8 ## 9 Jam 12 9 ## 10 Laura 12 10 ## # … with 338 more rows Näeme, et uus tulp on lisatud. Nüüd saame selle alusel omakorda võtta välja täpselt kolmanda koha selles tabelis, ükskõik, mis väärtusega n ka parasjagu ei ole. edetabel %&gt;% count(artist,sort=T) %&gt;% mutate(rownr = row_number()) %&gt;% filter(rownr == 3) ## # A tibble: 1 x 3 ## artist n rownr ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 2 Quick Start 24 3 Tidyverse lubab siinkohal ka natuke lõigata. Nimelt filtrisse minev number ei pruugi olla arvutatud, vaid selle võib ka filtreerimise käigus arvutada. Nii saab täpselt samad tulemused jättes ka mutate() käsu kõrvale. Sisuliselt siiski arvutab filter andmestikus uue muutuja, seda lihtsalt ei jäädvustata kusagile. edetabel %&gt;% count(artist,sort=T) %&gt;% filter(row_number() == 3) ## # A tibble: 1 x 2 ## artist n ## &lt;chr&gt; &lt;int&gt; ## 1 2 Quick Start 24 mutate() võib kohaldada igal pool. Näiteks võime lisada tabelisse väärtuse artisti kohast tähestiku jä edetabel %&gt;% arrange(artist) %&gt;% mutate(alphabet_rank = row_number()) ## # A tibble: 1,000 x 10 ## year rank votes artist song filename source lyrics language alphabet_rank ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 1994 7 NA 2 Quic… Olen… lyrics-… 1 &quot;1. P… et 1 ## 2 1994 9 NA 2 Quic… Sinu… lyrics-… 1 &quot;1. E… et 2 ## 3 1994 12 NA 2 Quic… Neiu… lyrics-… 1 &quot;On t… et 3 ## 4 1994 15 NA 2 Quic… King… lyrics-… 1 &quot;Olle… et 4 ## 5 1994 17 NA 2 Quic… Kaks… lyrics-… 1 &quot;Silm… et 5 ## 6 1995 14 287 2 Quic… Kirg… lyrics-… 1 &quot;enda… et 6 ## 7 1995 18 253 2 Quic… Siis… lyrics-… 1 &quot;Elu … et 7 ## 8 1995 33 110 2 Quic… King… lyrics-… 1 &quot;Olle… et 8 ## 9 1996 10 578 2 Quic… Lõpu… lyrics-… 1 &quot;Välg… et 9 ## 10 1996 18 290 2 Quic… Nii … lyrics-… 1 &quot;Sinu… et 10 ## # … with 990 more rows Ja võime sellest filtreerida välja esimesed 100 artisti tähestikus. edetabel %&gt;% arrange(artist) %&gt;% mutate(alphabet_rank = row_number()) %&gt;% filter(alphabet_rank&lt;101) ## # A tibble: 100 x 10 ## year rank votes artist song filename source lyrics language alphabet_rank ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 1994 7 NA 2 Quic… Olen… lyrics-… 1 &quot;1. P… et 1 ## 2 1994 9 NA 2 Quic… Sinu… lyrics-… 1 &quot;1. E… et 2 ## 3 1994 12 NA 2 Quic… Neiu… lyrics-… 1 &quot;On t… et 3 ## 4 1994 15 NA 2 Quic… King… lyrics-… 1 &quot;Olle… et 4 ## 5 1994 17 NA 2 Quic… Kaks… lyrics-… 1 &quot;Silm… et 5 ## 6 1995 14 287 2 Quic… Kirg… lyrics-… 1 &quot;enda… et 6 ## 7 1995 18 253 2 Quic… Siis… lyrics-… 1 &quot;Elu … et 7 ## 8 1995 33 110 2 Quic… King… lyrics-… 1 &quot;Olle… et 8 ## 9 1996 10 578 2 Quic… Lõpu… lyrics-… 1 &quot;Välg… et 9 ## 10 1996 18 290 2 Quic… Nii … lyrics-… 1 &quot;Sinu… et 10 ## # … with 90 more rows mutate() naaberkäsk on summarise(). Nad mõlemad püüavad tabelit muuta, mutate() teeb seda info lisamise või asendamise kaudu. summarise() teeb seda info kokkuvõtmise kaudu. Näiteks võime tabelist välja võtta selle esimese aasta ja viimase aasta min() ja max() kaudu. edetabel %&gt;% summarise(first=min(year), last=max(year)) ## # A tibble: 1 x 2 ## first last ## &lt;dbl&gt; &lt;dbl&gt; ## 1 1994 2018 Või võime ka kokku lugeda, mitu rida andmestikus on käsuga n(). edetabel %&gt;% summarise(n = n()) ## # A tibble: 1 x 1 ## n ## &lt;int&gt; ## 1 1000 mutate() ja summarise() käsud muudavad oluliselt oma käitumist kui andmestik on kuidagi grupeeritud. Nimelt kui andmestik on grupeeritud, tehakse neid arvutusi gruppide sees. Näiteks grupeerime andmestiku artistide kaupa ja võtame siis kokku, mitu rida seal on. 4.8 group_by() kasutamine edetabel %&gt;% group_by(artist) %&gt;% summarise(n=n()) %&gt;% arrange(desc(n)) ## # A tibble: 348 x 2 ## artist n ## &lt;chr&gt; &lt;int&gt; ## 1 Smilers 47 ## 2 Terminaator 46 ## 3 2 Quick Start 24 ## 4 Ines 21 ## 5 Tanel Padar &amp; The Sun 16 ## 6 Ott Lepland 15 ## 7 Caater 14 ## 8 Põhja-Tallinn 14 ## 9 Jam 12 ## 10 Laura 12 ## # … with 338 more rows Tähelepanelik lugeja märkab, et me saime täpselt sama tulemuse kui eelnevalt count() käsuga ning need käsud ongi täpselt samad. group_by() ja summarise() käskude kombinatsiooniga saab aga teha ka enamat. Näiteks võime välja võtta andmestikust info iga artisti esimese ja viimase aasta kohta kui nad said andmestikku. Nii saame ülevaate artistide kestvusest. edetabel %&gt;% group_by(artist) %&gt;% summarise(first=min(year), last=max(year)) ## # A tibble: 348 x 3 ## artist first last ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2 Quick Start 1994 2011 ## 2 2 Quick Start &amp; Hedvig Hanson 1995 1995 ## 3 4 Ever 1998 1998 ## 4 5miinust 2017 2017 ## 5 5MIINUST 2016 2016 ## 6 5MIINUST x Sass Henno 2018 2018 ## 7 6-Pack 1997 1997 ## 8 A-Rühm 1998 2008 ## 9 Agape 1994 1994 ## 10 Agent M 2006 2006 ## # … with 338 more rows Võime selle tabeli reastada algusaja järgi, et näha tabelis uusi tulijaid eespool. edetabel %&gt;% group_by(artist) %&gt;% summarise(first=min(year), last=max(year)) %&gt;% arrange(desc(last)) ## # A tibble: 348 x 3 ## artist first last ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 5MIINUST x Sass Henno 2018 2018 ## 2 Ans. Andur 2015 2018 ## 3 DND 2017 2018 ## 4 Egert Milder 2018 2018 ## 5 Elina Born ja Jüri Pootsmann 2018 2018 ## 6 Elina Nechayeva 2018 2018 ## 7 Evestus 2018 2018 ## 8 Frankie Animal 2018 2018 ## 9 Iiris 2011 2018 ## 10 Jüri Pootsmann 2015 2018 ## # … with 338 more rows mutate() käsuga võib andmestikust kätte saada täpselt sama info, aga selle asemel, et kokku võtta, lisab ta selle andmestikule. Näiteks eelmised käsud lisavad siis põhiandmestikule uued tulbad. edetabel %&gt;% group_by(artist) %&gt;% mutate(first=min(year), last=max(year)) ## # A tibble: 1,000 x 11 ## # Groups: artist [348] ## year rank votes artist song filename source lyrics language first last ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1994 1 NA Ummamu… Kõnõt… lyrics-… 1 &quot;:,:Vä… et 1994 1995 ## 2 1994 2 NA Vennas… Pille… lyrics-… 1 &quot;Taeva… et 1994 2000 ## 3 1994 3 NA Jam See 5 lyrics-… 1 &quot;See v… et 1994 2004 ## 4 1994 4 NA The Tu… Lille… lyrics-… 1 &quot;Tüdru… et 1994 2000 ## 5 1994 5 NA The Tu… Põhja… lyrics-… 1 &quot;Kui k… et 1994 2000 ## 6 1994 6 NA Jam Su Jä… lyrics-… 1 &quot;Enne … et 1994 2004 ## 7 1994 7 NA 2 Quic… Olen … lyrics-… 1 &quot;1. PÕ… et 1994 2011 ## 8 1994 8 NA Termin… Torm lyrics-… 1 &quot;Olen … et 1994 2017 ## 9 1994 9 NA 2 Quic… Sinu … lyrics-… 1 &quot;1. EK… et 1994 2011 ## 10 1994 10 NA D-Gän Seib lyrics-… 1 &quot;ELASI… et 1994 1994 ## # … with 990 more rows Samamoodi võib ka andmestikule lisada kui palju oli ühes grupis liikmeid. edetabel %&gt;% group_by(artist) %&gt;% mutate(n=n()) ## # A tibble: 1,000 x 10 ## # Groups: artist [348] ## year rank votes artist song filename source lyrics language n ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 1994 1 NA Ummamu… Kõnõtr… lyrics-um… 1 &quot;:,:Välän… et 2 ## 2 1994 2 NA Vennas… Pille-… lyrics-ve… 1 &quot;Taevas s… et 8 ## 3 1994 3 NA Jam See 5 lyrics-ja… 1 &quot;See viis… et 12 ## 4 1994 4 NA The Tu… Lillek… lyrics-th… 1 &quot;Tüdruk v… et 7 ## 5 1994 5 NA The Tu… Põhjam… lyrics-th… 1 &quot;Kui käes… et 7 ## 6 1994 6 NA Jam Su Jär… lyrics-ja… 1 &quot;Enne sin… et 12 ## 7 1994 7 NA 2 Quic… Olen L… lyrics-2_… 1 &quot;1. PÕHJU… et 24 ## 8 1994 8 NA Termin… Torm lyrics-te… 1 &quot;Olen tul… et 46 ## 9 1994 9 NA 2 Quic… Sinu J… lyrics-2_… 1 &quot;1. EKSIS… et 24 ## 10 1994 10 NA D-Gän Seib lyrics-d-… 1 &quot;ELASID K… et 1 ## # … with 990 more rows Sellisel juhul võime seda edasi töödelda ja võtta mitte ainult nimed, vaid ka kõik laulud tippartistidelt, kus artist oli tabelis rohkem kui kümne looga. edetabel %&gt;% group_by(artist) %&gt;% mutate(n=n()) %&gt;% filter(n&gt;10) ## # A tibble: 267 x 10 ## # Groups: artist [14] ## year rank votes artist song filename source lyrics language n ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 1994 3 NA Jam See 5 lyrics-ja… 1 &quot;See viis… et 12 ## 2 1994 6 NA Jam Su Jär… lyrics-ja… 1 &quot;Enne sin… et 12 ## 3 1994 7 NA 2 Quic… Olen L… lyrics-2_… 1 &quot;1. PÕHJU… et 24 ## 4 1994 8 NA Termin… Torm lyrics-te… 1 &quot;Olen tul… et 46 ## 5 1994 9 NA 2 Quic… Sinu J… lyrics-2_… 1 &quot;1. EKSIS… et 24 ## 6 1994 12 NA 2 Quic… Neiu M… lyrics-2_… 1 &quot;On tähin… et 24 ## 7 1994 15 NA 2 Quic… Kingit… lyrics-2_… 1 &quot;Olles kä… et 24 ## 8 1994 17 NA 2 Quic… Kaksik… lyrics-2_… 1 &quot;Silmade … et 24 ## 9 1994 18 NA Jam Tants … lyrics-ja… 1 &quot;Mis pane… et 12 ## 10 1994 22 NA Jam Miks M… lyrics-ja… 1 &quot;Kui sind… et 12 ## # … with 257 more rows Ja kokkuvõttes võime näiteks välja arvutada nende lugude keskmise koha. Siis kui me soovime gruppe jälle laiali lahutada, tuleb kasutada funktsiooni ungroup() edetabel %&gt;% group_by(artist) %&gt;% mutate(n=n()) %&gt;% filter(n&gt;10) %&gt;% ungroup() %&gt;% summarise(mean=mean(rank)) ## # A tibble: 1 x 1 ## mean ## &lt;dbl&gt; ## 1 17.5 Kui me gruppe laiali ei lahuta, mõõdame nii iga tippartisti keskmist tulemust edetabel %&gt;% group_by(artist) %&gt;% mutate(n=n()) %&gt;% filter(n&gt;10) %&gt;% summarise(mean=mean(rank)) ## # A tibble: 14 x 2 ## artist mean ## &lt;chr&gt; &lt;dbl&gt; ## 1 2 Quick Start 17.9 ## 2 Caater 14.1 ## 3 Ines 20.2 ## 4 Jam 19.8 ## 5 Karl-Erik Taukar 17 ## 6 Laura 15.6 ## 7 Nexus 21.3 ## 8 Ott Lepland 15.4 ## 9 Põhja-Tallinn 11.3 ## 10 Shanon 12.8 ## 11 Smilers 17.1 ## 12 Tanel Padar &amp; The Sun 16.3 ## 13 Terminaator 20.2 ## 14 Vanilla Ninja 19.8 group_by() muudab veidi ka teiste käskude käitumist. Kuivõrd filter võib viidata otse arvutusele ja mitte ainult tulbale, saab group_by() muuta ka selle käitumist. Näiteks kui me grupeeritud andmestikus kasutame filtrit ja arvutame sinna uue väärtuse, siis teeb ta seda grupi kaupa. Nii võime näiteks leida iga artisti esimesed lood, ilma uut tulpa tekitamata. edetabel %&gt;% group_by(artist) %&gt;% filter(year==min(year)) ## # A tibble: 477 x 9 ## # Groups: artist [348] ## year rank votes artist song filename source lyrics language ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1994 1 NA Ummamuu… Kõnõtr… lyrics-umma… 1 &quot;:,:Välän kü… et ## 2 1994 2 NA Vennask… Pille-… lyrics-venn… 1 &quot;Taevas sine… et ## 3 1994 3 NA Jam See 5 lyrics-jam-… 1 &quot;See viis ha… et ## 4 1994 4 NA The Tub… Lillek… lyrics-the_… 1 &quot;Tüdruk vaat… et ## 5 1994 5 NA The Tub… Põhjam… lyrics-the_… 1 &quot;Kui käes on… et ## 6 1994 6 NA Jam Su Jär… lyrics-jam-… 1 &quot;Enne sind e… et ## 7 1994 7 NA 2 Quick… Olen L… lyrics-2_qu… 1 &quot;1. PÕHJUST … et ## 8 1994 8 NA Termina… Torm lyrics-term… 1 &quot;Olen tulnud… et ## 9 1994 9 NA 2 Quick… Sinu J… lyrics-2_qu… 1 &quot;1. EKSISIN … et ## 10 1994 10 NA D-Gän Seib lyrics-d-ga… 1 &quot;ELASID KOOS… et ## # … with 467 more rows group_by() muudab ka select() veidi, kuna grupeerivaid faktoreid ei saa kõrvale jätta. Näiteks proovime seda eelmisel tabelil. edetabel %&gt;% group_by(artist) %&gt;% filter(year==min(year)) %&gt;% select(year,song) ## Adding missing grouping variables: `artist` ## # A tibble: 477 x 3 ## # Groups: artist [348] ## artist year song ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Ummamuudu 1994 Kõnõtraat ## 2 Vennaskond 1994 Pille-Riin ## 3 Jam 1994 See 5 ## 4 The Tuberkuloited 1994 Lilleke Rohus ## 5 The Tuberkuloited 1994 Põhjamaa Neid ## 6 Jam 1994 Su Järele Igatsen Ma ## 7 2 Quick Start 1994 Olen Loobuda Sust Proovinud ## 8 Terminaator 1994 Torm ## 9 2 Quick Start 1994 Sinu Jaoks ## 10 D-Gän 1994 Seib ## # … with 467 more rows Soovitav on sellisel juhul pärast igat grupeerimist andmestiku salvestamisel grupid uuesti lahti haakida. See aitab kaasa sellele, et vigu ei tekiks ja samas mõned funktsioonid ei tööta hästi grupeeritud andmetega - nad võivad üldse mitte toimida või muutuda väga aeglaselt kui töötluse peab tegema grupeeritud andmetega näiteks tuhandes väikses grupis ühe suure grupi asemel. edetabel %&gt;% group_by(artist) %&gt;% filter(year==min(year)) %&gt;% ungroup() %&gt;% select(year,song) ## # A tibble: 477 x 2 ## year song ## &lt;dbl&gt; &lt;chr&gt; ## 1 1994 Kõnõtraat ## 2 1994 Pille-Riin ## 3 1994 See 5 ## 4 1994 Lilleke Rohus ## 5 1994 Põhjamaa Neid ## 6 1994 Su Järele Igatsen Ma ## 7 1994 Olen Loobuda Sust Proovinud ## 8 1994 Torm ## 9 1994 Sinu Jaoks ## 10 1994 Seib ## # … with 467 more rows 4.9 Käskude ühendamine Mõtleme nüüd, kuidas võiks saada parima tulemuse saanud loo iga artisti kohta. Alustame andmete grupeerimisest artisti kaupa. edetabel %&gt;% group_by(artist) ## # A tibble: 1,000 x 9 ## # Groups: artist [348] ## year rank votes artist song filename source lyrics language ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1994 1 NA Ummamuu… Kõnõtr… lyrics-umma… 1 &quot;:,:Välän kü… et ## 2 1994 2 NA Vennask… Pille-… lyrics-venn… 1 &quot;Taevas sine… et ## 3 1994 3 NA Jam See 5 lyrics-jam-… 1 &quot;See viis ha… et ## 4 1994 4 NA The Tub… Lillek… lyrics-the_… 1 &quot;Tüdruk vaat… et ## 5 1994 5 NA The Tub… Põhjam… lyrics-the_… 1 &quot;Kui käes on… et ## 6 1994 6 NA Jam Su Jär… lyrics-jam-… 1 &quot;Enne sind e… et ## 7 1994 7 NA 2 Quick… Olen L… lyrics-2_qu… 1 &quot;1. PÕHJUST … et ## 8 1994 8 NA Termina… Torm lyrics-term… 1 &quot;Olen tulnud… et ## 9 1994 9 NA 2 Quick… Sinu J… lyrics-2_qu… 1 &quot;1. EKSISIN … et ## 10 1994 10 NA D-Gän Seib lyrics-d-ga… 1 &quot;ELASID KOOS… et ## # … with 990 more rows Kasutame funktsiooni arrange tulemuse alusel reastamiseks. edetabel %&gt;% group_by(artist) %&gt;% arrange(artist,rank) ## # A tibble: 1,000 x 9 ## # Groups: artist [348] ## year rank votes artist song filename source lyrics language ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2001 1 2149 2 Quic… Ühega M… lyrics-2_qu… 1 &quot;Võin niimoo… et ## 2 1998 3 NA 2 Quic… Teine P… lyrics-2_qu… 1 &quot;Su pilk on … et ## 3 1999 3 958 2 Quic… C&#39;est L… lyrics-2_qu… 1 &quot;Pilk peale … et ## 4 1994 7 NA 2 Quic… Olen Lo… lyrics-2_qu… 1 &quot;1. PÕHJUST … et ## 5 1994 9 NA 2 Quic… Sinu Ja… lyrics-2_qu… 1 &quot;1. EKSISIN … et ## 6 1996 10 578 2 Quic… Lõpuks … lyrics-2_qu… 1 &quot;Välgu valgu… et ## 7 1994 12 NA 2 Quic… Neiu Mu… lyrics-2_qu… 1 &quot;On tähine t… et ## 8 1995 14 287 2 Quic… Kirg su… lyrics-2_qu… 1 &quot;endale miks… et ## 9 1994 15 NA 2 Quic… Kingitus lyrics-2_qu… 1 &quot;Olles käsi … et ## 10 2002 15 319 2 Quic… Sa tead… lyrics-2_qu… 1 &quot;Läksin välj… et ## # … with 990 more rows Nüüd me peaksime kätte saama, mitmes paremuselt oli mõni lugu ühe grupi jaoks. Selleks lisame mutate() käsuga uue tulba. row_number() annab meile järjekorranumbri. Niisiis saame tulemused järjestatud artisti kaupa paremuse alusel. edetabel %&gt;% group_by(artist) %&gt;% arrange(artist,rank) %&gt;% mutate(artistbest=row_number()) ## # A tibble: 1,000 x 10 ## # Groups: artist [348] ## year rank votes artist song filename source lyrics language artistbest ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 2001 1 2149 2 Quic… Üheg… lyrics-2… 1 &quot;Võin n… et 1 ## 2 1998 3 NA 2 Quic… Tein… lyrics-2… 1 &quot;Su pil… et 2 ## 3 1999 3 958 2 Quic… C&#39;es… lyrics-2… 1 &quot;Pilk p… et 3 ## 4 1994 7 NA 2 Quic… Olen… lyrics-2… 1 &quot;1. PÕH… et 4 ## 5 1994 9 NA 2 Quic… Sinu… lyrics-2… 1 &quot;1. EKS… et 5 ## 6 1996 10 578 2 Quic… Lõpu… lyrics-2… 1 &quot;Välgu … et 6 ## 7 1994 12 NA 2 Quic… Neiu… lyrics-2… 1 &quot;On täh… et 7 ## 8 1995 14 287 2 Quic… Kirg… lyrics-2… 1 &quot;endale… et 8 ## 9 1994 15 NA 2 Quic… King… lyrics-2… 1 &quot;Olles … et 9 ## 10 2002 15 319 2 Quic… Sa t… lyrics-2… 1 &quot;Läksin… et 10 ## # … with 990 more rows Nüüd saame teha filtri ainult parimate lugude jaoks ja saamegi tulemuse kätte. edetabel %&gt;% group_by(artist) %&gt;% arrange(artist, rank) %&gt;% mutate(artistbest=row_number()) %&gt;% filter(artistbest==1) %&gt;% ungroup() ## # A tibble: 348 x 10 ## year rank votes artist song filename source lyrics language artistbest ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 2001 1 2149 2 Quic… Ühega… lyrics-… 1 &quot;Võin n… et 1 ## 2 1995 27 158 2 Quic… I Fee… &lt;NA&gt; NA &lt;NA&gt; &lt;NA&gt; 1 ## 3 1998 34 76 4 Ever Selle… &lt;NA&gt; NA &lt;NA&gt; &lt;NA&gt; 1 ## 4 2017 6 453 5miinu… Eroot… lyrics-… 1 &quot;Reede … et 1 ## 5 2016 19 96 5MIINU… Kuum lyrics-… 1 &quot;Nii ku… et 1 ## 6 2018 10 223 5MIINU… Trena… lyrics-… 1 &quot;KOREA:… et 1 ## 7 1997 2 1049 6-Pack Seest… &lt;NA&gt; NA &lt;NA&gt; &lt;NA&gt; 1 ## 8 1998 2 NA A-Rühm Popmu… lyrics-… 1 &quot;Kozy: … et 1 ## 9 1994 40 NA Agape Grung… &lt;NA&gt; NA &lt;NA&gt; &lt;NA&gt; 1 ## 10 2006 20 397 Agent M Šokol… lyrics-… 1 &quot;Kas tu… et 1 ## # … with 338 more rows Proovi ise! Kas suudad välja mõelda, kuidas eelmist tulemust saaks kätte ka vähema hulga ridade ja käskudega. #--------------------------------------------- #--------------------------------------------- Proovi ise! Kuidas saad kätte iga artisti paremuselt kümnenda loo? #--------------------------------------------- #--------------------------------------------- Kuidas saaks kätte iga artisti viimasena tabelisse pääsenud loo? #--------------------------------------------- #--------------------------------------------- 4.10 Uue muutuja loomine Lõpuks võib proovida mutate() kaudu arvutada välja mõne uue väärtuse. Näiteks, ütleme, et anname lugudele punkte, nii, et esimene koht annab 40 punkti ja 40. koht 1 punkti. Siis on punkti väärtus 41 miinus koht. edetabel %&gt;% mutate(skoor=41-rank) ## # A tibble: 1,000 x 10 ## year rank votes artist song filename source lyrics language skoor ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1994 1 NA Ummamu… Kõnõtr… lyrics-um… 1 &quot;:,:Välän… et 40 ## 2 1994 2 NA Vennas… Pille-… lyrics-ve… 1 &quot;Taevas s… et 39 ## 3 1994 3 NA Jam See 5 lyrics-ja… 1 &quot;See viis… et 38 ## 4 1994 4 NA The Tu… Lillek… lyrics-th… 1 &quot;Tüdruk v… et 37 ## 5 1994 5 NA The Tu… Põhjam… lyrics-th… 1 &quot;Kui käes… et 36 ## 6 1994 6 NA Jam Su Jär… lyrics-ja… 1 &quot;Enne sin… et 35 ## 7 1994 7 NA 2 Quic… Olen L… lyrics-2_… 1 &quot;1. PÕHJU… et 34 ## 8 1994 8 NA Termin… Torm lyrics-te… 1 &quot;Olen tul… et 33 ## 9 1994 9 NA 2 Quic… Sinu J… lyrics-2_… 1 &quot;1. EKSIS… et 32 ## 10 1994 10 NA D-Gän Seib lyrics-d-… 1 &quot;ELASID K… et 31 ## # … with 990 more rows Ja kui meil on olemas selline koondindeks võime proovida kokkku arvutada näiteks parima loo või parima artisti. Selleks saame kasutada funktsiooni summarise(). Näiteks terve tabeli peale saab võtta miinimum ja maksimum positsiooni. Kui me tahame saada parimat lugu selle punktisumma järgi, võime need punktisummad näiteks kokku liita iga loo kohta edetabel %&gt;% mutate(skoor=41-rank) %&gt;% group_by(song) %&gt;% summarise(summa=sum(skoor)) %&gt;% arrange(desc(summa)) ## # A tibble: 934 x 2 ## song summa ## &lt;chr&gt; &lt;dbl&gt; ## 1 Käime katuseid mööda 99 ## 2 Salaja 85 ## 3 Mälestused 83 ## 4 On Küll Hilja 74 ## 5 Torm 74 ## 6 Lootusetus 72 ## 7 Kaitseta 65 ## 8 Kingitus 60 ## 9 Mis Tegema Nüüd Pean 60 ## 10 Romula 60 ## # … with 924 more rows Käime katuseid mööda võidab suisa 99 punkti, mis tähendab et ta oli tabelis vähemalt kolmel aastal. Ja võime teha sama ka artisti kaupa ja arvutada välja populaarsuse määra, mis arvestab ka positsiooniga tabelis. Kui muidu oli lugude arvult Smilers ja Terminaator üsna ligi teineteisele, siis selle punktisumma järgi on Smilers siiski tublisti Terminaatorist ees. Terminaator vajaks veel 5-t esikümnehitti rohkem kui smilers, et talle järgi tulla. edetabel %&gt;% mutate(skoor=41-rank) %&gt;% group_by(artist) %&gt;% summarise(summa=sum(skoor)) %&gt;% arrange(desc(summa)) ## # A tibble: 348 x 2 ## artist summa ## &lt;chr&gt; &lt;dbl&gt; ## 1 Smilers 1124 ## 2 Terminaator 958 ## 3 2 Quick Start 555 ## 4 Ines 436 ## 5 Põhja-Tallinn 416 ## 6 Tanel Padar &amp; The Sun 395 ## 7 Ott Lepland 384 ## 8 Caater 377 ## 9 Shanon 339 ## 10 Laura 305 ## # … with 338 more rows Proovi ise! Mõtle välja uus muutuja, mida võiks arvutada ning mille alusel artiste järjestada. (Vihje: votes tulpa pole me siiani kasutanud.) #--------------------------------------------- #--------------------------------------------- 4.11 Sõnastik %&gt;% - vii andmed järgmisesse protsessi select() vali muutujad filter() vii andmestik läbi filtri/sõela unique() - võtab tabelist ainult unikaalsed read count() - loeb esinemiste arvu (võib panna mitu tulpa korraga) group_by() - grupeeri andmestik mingi muutuja alusel (võib panna mitu tulpa korraga) ungroup() - vii andmestik taas grupeerimata seisu n() - grupi suurus row_number() - rea number mutate() - loo uus muutuja arrange() - järjesta andmed, lisafunktsioon desc() summarise() - loob uue, kokkuvõtva, tulba 4.12 Harjutusülesanded Leidke artistid, kes olid kõige populaarsemad 2000ndatel. Leidke kõik lood, mis olid üle ühe aasta edetabelis. Leidke artistid, kel oli iga tabelisoldud aasta kohta kõige rohkem lugusid. Leidke lood, mis olid edetabelis mitu aastat. Nende lugude seast leidke lood, mille maksimaalne häälte hulk ületas nende minimaalse hääle hulga rohkem kui 5 korda. "],
["tidytext-ja-tekstitöötlus.html", "Peatükk 5 Tidytext ja tekstitöötlus 5.1 unnest_tokens() 5.2 Sagedussõnastikud 5.3 Stopsõnad 5.4 Võrdlus teise korpusega 5.5 Kordused laulu sees 5.6 Asukoht tekstis 5.7 Sõnastik 5.8 Harjutusülesanded", " Peatükk 5 Tidytext ja tekstitöötlus Selles peatükis teeme esimest tutvust tidytext paketiga, mis on loodud tidyverse stiilis tekstitöötluseks R-is. See pakett ei suuda teha kõike ja ei pruugi olla alati ka kõige kiirem, aga teeb siiski ära lihtsama tekstitöötluse, mida meil vaja võib minna. Kui tekib huvi juurde õppida, siis selle paketi enda juhend on siin https://www.tidytextmining.com/. Kui me alustasime R-i programmi uuesti on tarvis kõigepealt sisse lugeda paketid. library(tidyverse) tidytext pakett on tidyverse põhipaketist eraldi ning seetõttu tuleb eraldi sisse lugeda. Kui seda pole varem installitud, siis utleb ta ka installida. install.packages(&quot;tidytext&quot;) library(tidytext) Kui me käivitasime R-i uuesti, siis on meil vaja töötamiseks ka andmefail uuesti sisse lugeda. edetabel &lt;- read_tsv(&quot;data/eesti_top40/eesti_skyplus_top40_1994-2018.tsv&quot;) ## Parsed with column specification: ## cols( ## year = col_double(), ## rank = col_double(), ## votes = col_double(), ## artist = col_character(), ## song = col_character(), ## filename = col_character(), ## source = col_double(), ## lyrics = col_character(), ## language = col_character() ## ) 5.1 unnest_tokens() Peamine käsk, mis aitab meil tekstidega R-is töötada on unnest_tokens(). unnest_tokens() võtab sisendiks ühe tekstitunnuse ning jaotab ta mingil alusel elementideks (tokeniseerib). Näiteks siis saab teha tekstidest sõnaloendi. Kui see on tehtud asetab ta iga elemendi omale reale, järgides tidy data põhimõtteid, et meil peaks olema üks vaatlusobjekt rea kohta. Lisaks eemaldab ta tekstist numbrid, kirjavahemärgid, suurtähed ning teeb muud eeltöötlust, et eraldada elemendid tekstist. unnest_tokens() - muudab andmestikku nii et iga tekstitunnuse element oleks omal real. Vaatame kõigepealt selle lihtsamat tulemust. Järgmine käsk võtab andmestiku tunnnuse lyrics, teeb selle elementideks (mis on vaikimisi sõnad) ning salvestab kõik ‘word’ nimelisse tulpa. edetabel %&gt;% unnest_tokens(word,lyrics) ## # A tibble: 157,632 x 9 ## year rank votes artist song filename source language word ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et välän ## 2 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et külmetas ## 3 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et ja ## 4 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et taivast ## 5 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et satas ## 6 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et lummõ ## 7 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et ütle ## 8 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et mullõ ## 9 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et uma ## 10 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et telefoni… ## # … with 157,622 more rows Kui meil varem oli üks lugu tabelis iga rea kohta, siis nüüd on meil igal real üks sõna sellele kaasneva metainfoga. Ehk näha on midagi sellist. # A tibble: 157,632 x 9 # year rank votes artist song filename source language word # &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; # 1 1994 1 NA Ummamuudu Kõnõtraat lyrics-ummamuudu-konotraat 1 et välän # 2 1994 1 NA Ummamuudu Kõnõtraat lyrics-ummamuudu-konotraat 1 et külmetas # 3 1994 1 NA Ummamuudu Kõnõtraat lyrics-ummamuudu-konotraat 1 et ja # 4 1994 1 NA Ummamuudu Kõnõtraat lyrics-ummamuudu-konotraat 1 et taivast # 5 1994 1 NA Ummamuudu Kõnõtraat lyrics-ummamuudu-konotraat 1 et satas # 6 1994 1 NA Ummamuudu Kõnõtraat lyrics-ummamuudu-konotraat 1 et lummõ Kuna me kasutame seda andmekuju korduvalt ja tokeniseerimine võtab iga kord veidi aega, salvestame selle töötluse tulemuse ja viitame edaspidi juba töötluse lõpptulemusele. laulusonad &lt;- edetabel %&gt;% unnest_tokens(word,lyrics) Selle tabeliga saame teha samasuguseid operatsioone kui edetabeliga enne. Näiteks võime võtta kõik sõnad, mis on ühelt bändilt. laulusonad %&gt;% filter(artist==&quot;Smilers&quot;) ## # A tibble: 6,809 x 9 ## year rank votes artist song filename source language word ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1996 4 1192 Smilers Tahan Si… lyrics-smilers-ta… 1 et hella… ## 2 1996 4 1192 Smilers Tahan Si… lyrics-smilers-ta… 1 et luban ## 3 1996 4 1192 Smilers Tahan Si… lyrics-smilers-ta… 1 et sind ## 4 1996 4 1192 Smilers Tahan Si… lyrics-smilers-ta… 1 et hoida ## 5 1996 4 1192 Smilers Tahan Si… lyrics-smilers-ta… 1 et ma ## 6 1996 4 1192 Smilers Tahan Si… lyrics-smilers-ta… 1 et ja ## 7 1996 4 1192 Smilers Tahan Si… lyrics-smilers-ta… 1 et käia ## 8 1996 4 1192 Smilers Tahan Si… lyrics-smilers-ta… 1 et sind ## 9 1996 4 1192 Smilers Tahan Si… lyrics-smilers-ta… 1 et linna ## 10 1996 4 1192 Smilers Tahan Si… lyrics-smilers-ta… 1 et peal ## # … with 6,799 more rows laulusonad %&gt;% filter(artist==&quot;Terminaator&quot;) ## # A tibble: 7,006 x 9 ## year rank votes artist song filename source language word ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1994 8 NA Terminaat… Torm lyrics-terminaator… 1 et olen ## 2 1994 8 NA Terminaat… Torm lyrics-terminaator… 1 et tulnud ## 3 1994 8 NA Terminaat… Torm lyrics-terminaator… 1 et liiga ## 4 1994 8 NA Terminaat… Torm lyrics-terminaator… 1 et pikalt ## 5 1994 8 NA Terminaat… Torm lyrics-terminaator… 1 et teelt ## 6 1994 8 NA Terminaat… Torm lyrics-terminaator… 1 et tühja ## 7 1994 8 NA Terminaat… Torm lyrics-terminaator… 1 et maja ## 8 1994 8 NA Terminaat… Torm lyrics-terminaator… 1 et leids… ## 9 1994 8 NA Terminaat… Torm lyrics-terminaator… 1 et enda ## 10 1994 8 NA Terminaat… Torm lyrics-terminaator… 1 et eest ## # … with 6,996 more rows laulusonad %&gt;% filter(artist==&quot;Ummamuudu&quot;) ## # A tibble: 163 x 9 ## year rank votes artist song filename source language word ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et välän ## 2 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et külmetas ## 3 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et ja ## 4 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et taivast ## 5 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et satas ## 6 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et lummõ ## 7 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et ütle ## 8 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et mullõ ## 9 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et uma ## 10 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et telefoni… ## # … with 153 more rows Proovi ise! Vali välja üks artist ning võta tabelist välja ainult nende kasutatud sõnad #--------------------------------------------- #--------------------------------------------- 5.2 Sagedussõnastikud Et sõnade valikutest midagi huvitavat teada saada, võime hakata neid loendama - ehk siis teha sagedussõnastiku. laulusonad %&gt;% count(word,sort=T) ## # A tibble: 19,046 x 2 ## word n ## &lt;chr&gt; &lt;int&gt; ## 1 on 4401 ## 2 ja 3311 ## 3 ei 2872 ## 4 ma 2705 ## 5 kui 1980 ## 6 sa 1551 ## 7 see 1505 ## 8 et 1492 ## 9 me 1165 ## 10 veel 1088 ## # … with 19,036 more rows Nagu näeme, on enimkasutatud sõnad ka lauludes enamvähem samad kui keeles üldiselt. On, ja, ei, ma, kui, sa jne. Me võime filtrite abil koostada ka sagedussõnastiku mõnele üksikule artistile ja vaadata neid ühekaupa. laulusonad %&gt;% filter(artist==&quot;Põhja-Tallinn&quot;) %&gt;% count(word,sort=T) ## # A tibble: 1,635 x 2 ## word n ## &lt;chr&gt; &lt;int&gt; ## 1 ei 219 ## 2 on 189 ## 3 ja 147 ## 4 ma 146 ## 5 kui 117 ## 6 et 108 ## 7 kõik 98 ## 8 veel 71 ## 9 sa 62 ## 10 mis 56 ## # … with 1,625 more rows laulusonad %&gt;% filter(artist==&quot;Ummamuudu&quot;) %&gt;% count(word,sort=T) ## # A tibble: 80 x 2 ## word n ## &lt;chr&gt; &lt;int&gt; ## 1 ära 15 ## 2 su 14 ## 3 tunnen 14 ## 4 ja 11 ## 5 ma 7 ## 6 sinu 7 ## 7 mullõ 5 ## 8 telefoninummõr 5 ## 9 uma 5 ## 10 ütle 3 ## # … with 70 more rows laulusonad %&gt;% filter(artist==&quot;Nublu&quot;) %&gt;% count(word,sort=T) ## # A tibble: 312 x 2 ## word n ## &lt;chr&gt; &lt;int&gt; ## 1 ka 39 ## 2 ja 29 ## 3 ma 29 ## 4 mina 29 ## 5 sa 23 ## 6 ou 22 ## 7 nagu 18 ## 8 kui 15 ## 9 ei 13 ## 10 siis 13 ## # … with 302 more rows Proovi ise! Vali välja üks artist ning vaata nende enimkasutatud sõnu. #--------------------------------------------- #--------------------------------------------- 5.3 Stopsõnad Leiame, et nagu ikka eesti keeles, on ka lauludes levinumad sõnad sidesõnad ja asesõnad ja muu selline. Nagu meil loengust läbi käis on siis tihti kasulik eemaldada stopsõnad, et saada selgemalt aru, mis laule teineteisest erinevad ja millest need lood räägivad. Me võime kasutada ükskõik, millist tabelit sõnade loendina. Eesti keele jaoks on olemas hea stopsõnade loend siin http://datadoi.ut.ee/handle/33/78. Loeme selle sisse eraldi tabelina. stopsonad &lt;- read_tsv(&quot;data/uiboaed_stopwords/estonian-stopwords.txt&quot;,col_names = &quot;word&quot;) ## Parsed with column specification: ## cols( ## word = col_character() ## ) Nüüd on meil kaks tabelit ja me soovine neid omavahel võrrelda ja ühendada. Selleks on olemas tidyverse paketis join() käsud. join() käsud võtavad tabelis ühe või mitu tunnust ning proovib seda klapitada valitud tunnuse või tunnustega teises tabelis. Kõik read, kus on tunnuste kaupa täpselt sama väärtus on võimalik ühendada. Teistes pakettides kasutatakse siin merge() käsku, mis töötab sama loogikaga. Vaatame kõigepealt pildiülevaadet juhendis. Pildi peal on kujutatud see ridadehulk, mis alles jääb. Täpsemalt öeldes, left_join() hoiab esimese tabeli terviklikuna. right_join() hoiab teise tabeli terviklikuna. inner_join() hoiab alles ainult kattuvad read. full_join() hoiab mõlemad tabelid terviklikuna. Ning anti_join() eemaldab teise tabeliga kattuvad read esimesest tabelist. -left_join() - liidab vasakpoolse andmestiku külge need read, mis sobivad paremast. - right_join() - liidab parempoolse andmestiku külge need read, mis sobivad vasakust. - inner_join() - jätab alles ainult sobivad read kummastki - full_join() - jätab alles kõik read mõlemast tabelist, isegi kui ükski ei kattu. - anti_join() - töötab vastupidiselt ja eemaldab vasakust kõik read, mis ühtivad parempoolse tabeliga. Hetkel on meil kaks tabelit. Käivita järgmised read, et neid näha. laulusonad ## # A tibble: 157,632 x 9 ## year rank votes artist song filename source language word ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et välän ## 2 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et külmetas ## 3 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et ja ## 4 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et taivast ## 5 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et satas ## 6 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et lummõ ## 7 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et ütle ## 8 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et mullõ ## 9 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et uma ## 10 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et telefoni… ## # … with 157,622 more rows stopsonad ## # A tibble: 5,025 x 1 ## word ## &lt;chr&gt; ## 1 minutaolisteks ## 2 veeres ## 3 samadeks ## 4 karkääksti ## 5 mihukeste ## 6 ii-ha-ha ## 7 milliseist ## 8 selleks ## 9 mõlemate ## 10 praeguseiks ## # … with 5,015 more rows Nüüd, liidame tabeli ‘laulusonad’ tabeliga ‘stopsonad’, kasutades inner_join() funktsiooni ja teeme seda “word” nimelise tulba kaudu, mis on mõlemas tabelis olemas. Tegelikult otsivad tidyverse join() käsud ka ise samanimelisi tulpasid ja kui neile täpsemaid juhiseid pole antud, siis ühendavad need. Kui me tegeleme uue andmestikuga on kasulik see alati välja kirjutada, et ei tekiks vigu. laulusonad %&gt;% inner_join(stopsonad,by=&quot;word&quot;) ## # A tibble: 67,862 x 9 ## year rank votes artist song filename source language word ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1994 1 NA Ummamuudu Kõnõtra… lyrics-ummamuudu-… 1 et ja ## 2 1994 1 NA Ummamuudu Kõnõtra… lyrics-ummamuudu-… 1 et su ## 3 1994 1 NA Ummamuudu Kõnõtra… lyrics-ummamuudu-… 1 et läbi ## 4 1994 1 NA Ummamuudu Kõnõtra… lyrics-ummamuudu-… 1 et meil ## 5 1994 1 NA Ummamuudu Kõnõtra… lyrics-ummamuudu-… 1 et ja ## 6 1994 1 NA Ummamuudu Kõnõtra… lyrics-ummamuudu-… 1 et ja ## 7 1994 2 NA Vennasko… Pille-R… lyrics-vennaskond… 1 et ja ## 8 1994 2 NA Vennasko… Pille-R… lyrics-vennaskond… 1 et kuhu… ## 9 1994 2 NA Vennasko… Pille-R… lyrics-vennaskond… 1 et on ## 10 1994 2 NA Vennasko… Pille-R… lyrics-vennaskond… 1 et on ## # … with 67,852 more rows See käsk niisiis leidis ainult kattuvad read kahes tabelis ning seeläbi jättis alles kõikidest lugudest ainult stopsõnad. Kui meid huvitavad näiteks asesõnade kasutus või sõnakordused, siis võimalik, et täpselt see meid huvitabki. Me võime proovida neid kahte tabelit liita left_join() funktsiooni kaudu. Sellega küll ei muutu midagi, kuna liidetud tabel stopsonad sisaldabki ainult ühte tulpa, ning liidetud sõnad sulanduvad esimesse tabelisse. laulusonad %&gt;% left_join(stopsonad,by=&quot;word&quot;) ## # A tibble: 157,632 x 9 ## year rank votes artist song filename source language word ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et välän ## 2 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et külmetas ## 3 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et ja ## 4 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et taivast ## 5 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et satas ## 6 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et lummõ ## 7 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et ütle ## 8 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et mullõ ## 9 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et uma ## 10 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et telefoni… ## # … with 157,622 more rows Et kattuvad read ära markeerida võime teha stopsõnade tabelisse uue tulba, mis märgib, et on tõene, et see sõna on stopsõna. stopsonad2 &lt;- stopsonad %&gt;% mutate(onstopsona=TRUE) Kui me nüüd ühendame tabelid left_join() kaudu, siis saame kaasa ka selle lisatulba. laulusonad %&gt;% left_join(stopsonad2,by=&quot;word&quot;) ## # A tibble: 157,632 x 10 ## year rank votes artist song filename source language word onstopsona ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; ## 1 1994 1 NA Ummamu… Kõnõt… lyrics-um… 1 et välän NA ## 2 1994 1 NA Ummamu… Kõnõt… lyrics-um… 1 et külme… NA ## 3 1994 1 NA Ummamu… Kõnõt… lyrics-um… 1 et ja TRUE ## 4 1994 1 NA Ummamu… Kõnõt… lyrics-um… 1 et taiva… NA ## 5 1994 1 NA Ummamu… Kõnõt… lyrics-um… 1 et satas NA ## 6 1994 1 NA Ummamu… Kõnõt… lyrics-um… 1 et lummõ NA ## 7 1994 1 NA Ummamu… Kõnõt… lyrics-um… 1 et ütle NA ## 8 1994 1 NA Ummamu… Kõnõt… lyrics-um… 1 et mullõ NA ## 9 1994 1 NA Ummamu… Kõnõt… lyrics-um… 1 et uma NA ## 10 1994 1 NA Ummamu… Kõnõt… lyrics-um… 1 et telef… NA ## # … with 157,622 more rows Lihtsa väljundina võime näiteks kokku lugeda kumba on kui palju on kokku neid stopsõnu ja kui palju on muid sõnu (ehk neid, millel puudub informatsioon selle kohta, kas ta on stopsõna). laulusonad %&gt;% left_join(stopsonad2,by=&quot;word&quot;) %&gt;% count(onstopsona) ## # A tibble: 2 x 2 ## onstopsona n ## &lt;lgl&gt; &lt;int&gt; ## 1 TRUE 67862 ## 2 NA 89770 Seal näeme, et teksti koguhulgast on stopsõnu veidi alla poole ja veidi üle poole on kõiki muid sõnu. Samal põhimõttel võime ka leida kõige stopsõnaderikkama laulu. laulusonad %&gt;% left_join(stopsonad2,by=&quot;word&quot;) %&gt;% group_by(artist,song) %&gt;% count(onstopsona) %&gt;% mutate(proportsioon=n/sum(n)) %&gt;% # proportsiooni võime arvutada jagades loendatud arvu kõikide arvude summaga. # kuna tabel on ikka veel gruppideks jaotatud, siis seda loetakse iga artisti-laulu sees filter(onstopsona==TRUE) %&gt;% arrange(desc(proportsioon)) ## # A tibble: 781 x 5 ## # Groups: artist, song [781] ## artist song onstopsona n proportsioon ## &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Hnd Kui Sa Vaid Saad TRUE 80 0.762 ## 2 HND Kui sa vaid saad TRUE 80 0.762 ## 3 Ott Lepland Siin me kokku saime TRUE 139 0.739 ## 4 Nancy Keegi Teine TRUE 84 0.724 ## 5 Jam Ei pea iial TRUE 145 0.721 ## 6 HU? Mina Ise TRUE 90 0.714 ## 7 Ines Ma ei tea mis juhtuks TRUE 188 0.709 ## 8 Ott Lepland Otsides Ma Pean Su Jälle L… TRUE 61 0.709 ## 9 Jam Ainus Tee TRUE 213 0.708 ## 10 Vaiko Eplik Ja Eli… Armastus Päästab Maailma TRUE 69 0.704 ## # … with 771 more rows Ja saame loo HND ‘Kui sa vaid saad’, millel on kolm neljandikku sõnu stopsõnad. Ainuüksi pealkiri koosnebki ainult stopsõnadest. Proovi ise! Vali välja üks artist ja vaata milliseid stopsõnu nad kasutavad ja kui palju. #--------------------------------------------- #--------------------------------------------- Enamasti on aga stopsõnade nimekiri kasulik, et need sõnad tekstist eemaldada. Näiteks võime võtta sama tabeli ja jätta alles ainult sõnad, mis ei ole stopsõnad. Selleks kasutame algusest tuttavat funktsiooni is.na(), mis kontrollib kas väärtus on puuduv. onstopsona == NA ei töötaks, kuna R-i jaoks on puuduvad väärtused erilised. laulusonad %&gt;% left_join(stopsonad2,by=&quot;word&quot;) %&gt;% filter(is.na(onstopsona)) ## # A tibble: 89,770 x 10 ## year rank votes artist song filename source language word onstopsona ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; ## 1 1994 1 NA Ummamu… Kõnõt… lyrics-um… 1 et välän NA ## 2 1994 1 NA Ummamu… Kõnõt… lyrics-um… 1 et külme… NA ## 3 1994 1 NA Ummamu… Kõnõt… lyrics-um… 1 et taiva… NA ## 4 1994 1 NA Ummamu… Kõnõt… lyrics-um… 1 et satas NA ## 5 1994 1 NA Ummamu… Kõnõt… lyrics-um… 1 et lummõ NA ## 6 1994 1 NA Ummamu… Kõnõt… lyrics-um… 1 et ütle NA ## 7 1994 1 NA Ummamu… Kõnõt… lyrics-um… 1 et mullõ NA ## 8 1994 1 NA Ummamu… Kõnõt… lyrics-um… 1 et uma NA ## 9 1994 1 NA Ummamu… Kõnõt… lyrics-um… 1 et telef… NA ## 10 1994 1 NA Ummamu… Kõnõt… lyrics-um… 1 et hamõ NA ## # … with 89,760 more rows Täpselt sama teeb ka käsk anti_join(), mis jätab kõrvale kõik read, kus tunnused on sama väärtusega. Seda kasutame ka edaspidi. laulusonad %&gt;% anti_join(stopsonad,by=&quot;word&quot;) ## # A tibble: 89,770 x 9 ## year rank votes artist song filename source language word ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et välän ## 2 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et külmetas ## 3 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et taivast ## 4 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et satas ## 5 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et lummõ ## 6 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et ütle ## 7 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et mullõ ## 8 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et uma ## 9 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et telefoni… ## 10 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et hamõ ## # … with 89,760 more rows Sellega loendada kokku kõik sõnad, mis pole stopsõnad ja teha neist sagedustabeli. laulusonad %&gt;% anti_join(stopsonad,by=&quot;word&quot;) %&gt;% count(word,sort=T) ## # A tibble: 18,164 x 2 ## word n ## &lt;chr&gt; &lt;int&gt; ## 1 the 1033 ## 2 you 1021 ## 3 to 658 ## 4 and 572 ## 5 my 465 ## 6 it 442 ## 7 ref 374 ## 8 täna 325 ## 9 tean 296 ## 10 hea 289 ## # … with 18,154 more rows Nüüd näeme veel üht probleemi meie sõnaloendis. Paljud lood on ingliskeelsed ja seal on ka hulk sagedasi sõnu, mis samuti esiotsa pürgivad. Tabelis on olemas ka tunnus loo keele kohta ning selle abil võime piirduda edasi ainult eestikeelsete lugudega. Eestikeelsed lood on siin tähistatud rahvusvahelise tähisega ‘et’. laulusonad %&gt;% anti_join(stopsonad,by=&quot;word&quot;) %&gt;% filter(language==&quot;et&quot;) %&gt;% count(word,sort=T) ## # A tibble: 15,823 x 2 ## word n ## &lt;chr&gt; &lt;int&gt; ## 1 ref 360 ## 2 täna 325 ## 3 tean 296 ## 4 hea 289 ## 5 aeg 280 ## 6 päev 279 ## 7 öö 264 ## 8 taas 258 ## 9 elu 257 ## 10 jälle 226 ## # … with 15,813 more rows Saadud tabel on juba veidi informatiivsem # A tibble: 15,823 x 2 # word n # &lt;chr&gt; &lt;int&gt; # 1 ref 360 # 2 täna 325 # 3 tean 296 # 4 hea 289 # 5 aeg 280 # 6 päev 279 # 7 öö 264 # 8 taas 258 # 9 elu 257 # 10 jälle 226 ref viitab siin refräänile. muidu on sagedased päev, öö, taas, jälle, hea, aeg, täna, tean. Olenevalt sellest, mis meid huvitab, tasub meil stopsõnadenimekirja žanrile kohandada. Näiteks võime siin lisaks stopsõnadele tabelist välja võtta ka sõna ‘ref’. laulusonad %&gt;% anti_join(stopsonad,by=&quot;word&quot;) %&gt;% filter(language==&quot;et&quot;) %&gt;% count(word,sort=T) %&gt;% filter(!word %in% c(&quot;ref&quot;)) #Hüüumärk näitab eitust ## # A tibble: 15,822 x 2 ## word n ## &lt;chr&gt; &lt;int&gt; ## 1 täna 325 ## 2 tean 296 ## 3 hea 289 ## 4 aeg 280 ## 5 päev 279 ## 6 öö 264 ## 7 taas 258 ## 8 elu 257 ## 9 jälle 226 ## 10 kord 214 ## # … with 15,812 more rows Salvestame selle tabeli samuti edasiseks kasutuseks. sonaloend &lt;- laulusonad %&gt;% anti_join(stopsonad,by=&quot;word&quot;) %&gt;% filter(language==&quot;et&quot;) %&gt;% count(word,sort=T) %&gt;% filter(!word %in% c(&quot;ref&quot;)) 5.4 Võrdlus teise korpusega Me võime nüüd mõelda, kui tüüpiline meie laulusõnade korpus on võrreldes keelega üldisemalt. Nagu loengutes sai räägitud, on selleks kasulik vaadata sõnade suhtelist osakaalu korpuses, mitte absoluutarvu, kuna tekstikogude suurused võivad olla väga erinevad. Niisiis saame jagada leitud sõnade arvu kõikide sõnade arvu hulgaga, saades kätte millise proportsiooni see sõna tervikkorpusest moodustab. sonaloend %&gt;% mutate(proportsioon=n/sum(n)) ## # A tibble: 15,822 x 3 ## word n proportsioon ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 täna 325 0.00498 ## 2 tean 296 0.00454 ## 3 hea 289 0.00443 ## 4 aeg 280 0.00429 ## 5 päev 279 0.00428 ## 6 öö 264 0.00405 ## 7 taas 258 0.00395 ## 8 elu 257 0.00394 ## 9 jälle 226 0.00346 ## 10 kord 214 0.00328 ## # … with 15,812 more rows Meil on võimalik seda proportsiooni võrrelda eesti ilukirjandusest tehtud korpusega. Ühe sellise korpuse kohta on sõnasageduste statistika saadaval siin. http://datadoi.ut.ee/handle/33/41. Loeme sisse sõnade sageduse info. ilukirj_sonad &lt;- read_tsv(&quot;data/raudvere_uiboaed_mitmikud/token_1_grams.tsv&quot;,col_names = c(&quot;word&quot;,&quot;n_token&quot;,&quot;n_docs&quot;)) ## Parsed with column specification: ## cols( ## word = col_character(), ## n_token = col_double(), ## n_docs = col_double() ## ) ilukirj_sonad &lt;- ilukirj_sonad %&gt;% mutate(prop_ilukirj=round(n_token/sum(n_token),3)) Samamoodi nagu stopsõnade puhul, saame me nüüd ühendada need kaks tabelit. sonaloend %&gt;% mutate(proportsioon=n/sum(n)) %&gt;% left_join(ilukirj_sonad, by=&quot;word&quot;) ## # A tibble: 15,822 x 6 ## word n proportsioon n_token n_docs prop_ilukirj ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 täna 325 0.00498 2787 88 0.001 ## 2 tean 296 0.00454 1552 84 0 ## 3 hea 289 0.00443 5133 90 0.001 ## 4 aeg 280 0.00429 3523 90 0.001 ## 5 päev 279 0.00428 1899 90 0 ## 6 öö 264 0.00405 784 82 0 ## 7 taas 258 0.00395 1796 83 0 ## 8 elu 257 0.00394 5460 90 0.001 ## 9 jälle 226 0.00346 4416 88 0.001 ## 10 kord 214 0.00328 3319 89 0.001 ## # … with 15,812 more rows Vaadates nüüd väljatrükitud esikümmet võime näha, et suhtelise sageduse järgi on aeg, elu, jälle ja kord ikukirjanduses sagedasemad kui lauludes. Samas on öö, päev ja tean, vastupidi, sagedasemad just laulusõnades. Need erinevused võivad olla suuremad keskmise levikuga sõnade kohta. Proovi vaadata ise mõne valitud sõna kohta, kuidas nende sagedused erinevad. #--------------------------------------------- #--------------------------------------------- Kui meil on stopsõnad eemaldatud, võime ka vaadata kindlate artistide levinumaid sõnu, mis võiksid väljendada ka paremini nende lugude sisu. Niisiis, teeme sagedussõnastikud nende artistide kohta ja vaatame lähemalt. laulusonad %&gt;% anti_join(stopsonad,by=&quot;word&quot;) %&gt;% filter(artist==&quot;Põhja-Tallinn&quot;) %&gt;% count(word,sort=T) ## # A tibble: 1,312 x 2 ## word n ## &lt;chr&gt; &lt;int&gt; ## 1 aega 36 ## 2 tean 26 ## 3 maailm 25 ## 4 saadab 23 ## 5 koju 20 ## 6 elu 19 ## 7 hea 19 ## 8 kallis 15 ## 9 küsin 14 ## 10 nõu 14 ## # … with 1,302 more rows laulusonad %&gt;% anti_join(stopsonad,by=&quot;word&quot;) %&gt;% filter(artist==&quot;Ummamuudu&quot;) %&gt;% count(word,sort=T) ## # A tibble: 62 x 2 ## word n ## &lt;chr&gt; &lt;int&gt; ## 1 tunnen 14 ## 2 mullõ 5 ## 3 telefoninummõr 5 ## 4 uma 5 ## 5 ütle 3 ## 6 lummõ 2 ## 7 refr 2 ## 8 satas 2 ## 9 sis 2 ## 10 utle 2 ## # … with 52 more rows laulusonad %&gt;% anti_join(stopsonad,by=&quot;word&quot;) %&gt;% filter(artist==&quot;Nublu&quot;) %&gt;% count(word,sort=T) ## # A tibble: 220 x 2 ## word n ## &lt;chr&gt; &lt;int&gt; ## 1 ou 22 ## 2 pa 10 ## 3 öö 6 ## 4 parap 6 ## 5 täna 6 ## 6 võtan 5 ## 7 bonnie 4 ## 8 cappuccino 4 ## 9 clyde 4 ## 10 hüppan 4 ## # … with 210 more rows Proovi ise! Vali välja üks artist ning vaata nende enimkasutatud sõnu ilma stopsõnadeta. #--------------------------------------------- #--------------------------------------------- 5.5 Kordused laulu sees Just laulusõnade puhul võib isegi artistidest huvitavamaks osutuda üksiklaulude vaatamine. Näiteks, kuna paljudel lauludel on refräänid (mõnikord on need küll andmetes ainult üks kord), siis võib oodata neil palju sõnakordusi. Et teha sõnaloendeid laulude kohta, grupeerime tabeli kõigepealt laulude kaupa ning mõõdame sõnasagedusi sellel põhjal. Me võime siis vaadata näiteks kui suure osa kogu laulu sõnadest moodustab mõni konkreetne sõna. laulusonad %&gt;% filter(language==&quot;et&quot;) %&gt;% group_by(artist, song) %&gt;% count(word,sort=T) %&gt;% filter(!word %in% c(&quot;ref&quot;)) %&gt;% mutate(proportsioon=n/sum(n)) %&gt;% arrange(desc(proportsioon)) ## # A tibble: 63,710 x 5 ## # Groups: artist, song [650] ## artist song word n proportsioon ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Planeet Satelliidid satelliid… 36 0.621 ## 2 The Tuberkuloited Tantsin Valssi na 72 0.319 ## 3 Tuberkuloited &amp; Urmas Voolpri… Tantsin valssi na 72 0.319 ## 4 Kosmikud Öö Ei Lase Maga… magada 33 0.287 ## 5 Mari-Leen 1987 o 60 0.275 ## 6 HU? Elupõletaja ei 53 0.233 ## 7 Anaconda Veel Veel Veel veel 31 0.218 ## 8 Koer Maiu on piimaau… maiu 16 0.205 ## 9 Koer Maiu on piimaau… on 16 0.205 ## 10 Koer Maiu on piimaau… piimaauto 16 0.205 ## # … with 63,700 more rows Saame tulemuseks, et laulus satelliidid esineb sõn satelliidid 36 korda, see on üle poole sisust. Samas kui laulus Maiu on piimaauto, on nii maiu, on kui piimaauto 16 korda, ehk 20% kõigist sõnadest. Proovi ise! Kui lugeda mitte proportsiooni järgi vaid koguarvult, siis mis sõna on kõige rohkem ühe laulu sees kordumas ja mis laulus? #--------------------------------------------- #--------------------------------------------- Kui palju muutub tabel kui eemaldada stopsõnad? #--------------------------------------------- #--------------------------------------------- 5.6 Asukoht tekstis Kasutades etteantud vahendeid on võimalik ka esitada küsimusi sõnade asukoha kohta. Näiteks, et kui laul kasutas sõna satelliidid nii palju kordi, siis kas seda laulu lõpus või alguses või läbivalt igal pool. Selleks saame kasutada käske group_by(), mutate() ja row_number(). Nimelt, et kui me vaatasime eelmises peatükis edetabeleid row_number() kaudu, siis nüüd võime kasutada seda ka sõnadel nende loomulikus järjekorras. Numbrid ühest kuni loo pikkuseni viitavad sõna asukohale tekstis. Niisiis, saame iga laulu sees sõna asukoha grupeerides laulud eraldi ning lisades uue tulba row_number(). laulusonad %&gt;% group_by(artist,song,year) %&gt;% mutate(nr=row_number()) ## # A tibble: 157,632 x 10 ## # Groups: artist, song, year [999] ## year rank votes artist song filename source language word nr ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 1994 1 NA Ummamu… Kõnõtr… lyrics-ummam… 1 et välän 1 ## 2 1994 1 NA Ummamu… Kõnõtr… lyrics-ummam… 1 et külmet… 2 ## 3 1994 1 NA Ummamu… Kõnõtr… lyrics-ummam… 1 et ja 3 ## 4 1994 1 NA Ummamu… Kõnõtr… lyrics-ummam… 1 et taivast 4 ## 5 1994 1 NA Ummamu… Kõnõtr… lyrics-ummam… 1 et satas 5 ## 6 1994 1 NA Ummamu… Kõnõtr… lyrics-ummam… 1 et lummõ 6 ## 7 1994 1 NA Ummamu… Kõnõtr… lyrics-ummam… 1 et ütle 7 ## 8 1994 1 NA Ummamu… Kõnõtr… lyrics-ummam… 1 et mullõ 8 ## 9 1994 1 NA Ummamu… Kõnõtr… lyrics-ummam… 1 et uma 9 ## 10 1994 1 NA Ummamu… Kõnõtr… lyrics-ummam… 1 et telefo… 10 ## # … with 157,622 more rows Kuna lood on erineva pikkusega, siis on võrdluse huvides ehk kasulik vaadata loo pikkust protsentidena. Selleks võime lisada ka loendi n() kaudu. mutate() võimaldab nii lisada mitu uut tunnust. laulusonad %&gt;% group_by(artist,song,year) %&gt;% mutate(nr=row_number(), n=n()) ## # A tibble: 157,632 x 11 ## # Groups: artist, song, year [999] ## year rank votes artist song filename source language word nr n ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 1994 1 NA Ummamu… Kõnõ… lyrics-um… 1 et välän 1 52 ## 2 1994 1 NA Ummamu… Kõnõ… lyrics-um… 1 et külme… 2 52 ## 3 1994 1 NA Ummamu… Kõnõ… lyrics-um… 1 et ja 3 52 ## 4 1994 1 NA Ummamu… Kõnõ… lyrics-um… 1 et taiva… 4 52 ## 5 1994 1 NA Ummamu… Kõnõ… lyrics-um… 1 et satas 5 52 ## 6 1994 1 NA Ummamu… Kõnõ… lyrics-um… 1 et lummõ 6 52 ## 7 1994 1 NA Ummamu… Kõnõ… lyrics-um… 1 et ütle 7 52 ## 8 1994 1 NA Ummamu… Kõnõ… lyrics-um… 1 et mullõ 8 52 ## 9 1994 1 NA Ummamu… Kõnõ… lyrics-um… 1 et uma 9 52 ## 10 1994 1 NA Ummamu… Kõnõ… lyrics-um… 1 et telef… 10 52 ## # … with 157,622 more rows Ja kui meil on olemas nii rea number kui ridade arv võime välja arvutada sõna suhtelise asukoha. Lisame selleks tunnusele n ühe, et kõik tulemused oleks väiksem kui üks. laulusonad %&gt;% group_by(artist,song,year) %&gt;% mutate(nr=row_number(), n=n()) %&gt;% mutate(asukoht=nr/(n+1)) ## # A tibble: 157,632 x 12 ## # Groups: artist, song, year [999] ## year rank votes artist song filename source language word nr n ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 1994 1 NA Ummam… Kõnõ… lyrics-… 1 et välän 1 52 ## 2 1994 1 NA Ummam… Kõnõ… lyrics-… 1 et külm… 2 52 ## 3 1994 1 NA Ummam… Kõnõ… lyrics-… 1 et ja 3 52 ## 4 1994 1 NA Ummam… Kõnõ… lyrics-… 1 et taiv… 4 52 ## 5 1994 1 NA Ummam… Kõnõ… lyrics-… 1 et satas 5 52 ## 6 1994 1 NA Ummam… Kõnõ… lyrics-… 1 et lummõ 6 52 ## 7 1994 1 NA Ummam… Kõnõ… lyrics-… 1 et ütle 7 52 ## 8 1994 1 NA Ummam… Kõnõ… lyrics-… 1 et mullõ 8 52 ## 9 1994 1 NA Ummam… Kõnõ… lyrics-… 1 et uma 9 52 ## 10 1994 1 NA Ummam… Kõnõ… lyrics-… 1 et tele… 10 52 ## # … with 157,622 more rows, and 1 more variable: asukoht &lt;dbl&gt; Selle tulemuse põhjal saame arvutada, millisel kümnendikul loos sõna paikneb. Selleks võime korrutada asukoha, mis on nullist üheni, kümnega, et saada vahemiku 0-st 10-ni ja iga tulemuse ümardada alla, et kätte saada, millises kümnendikus sõna esines. Kui me jagame selle uuesti 10-ga saame kätte väärtused 0, 0.1, 0.2 … 0.9. laulusonad %&gt;% group_by(artist,song,year) %&gt;% mutate(nr=row_number(), n=n()) %&gt;% mutate(asukoht=nr/(n+1)) %&gt;% mutate(asukoht_perc=floor(asukoht*10)/10) ## # A tibble: 157,632 x 13 ## # Groups: artist, song, year [999] ## year rank votes artist song filename source language word nr n ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 1994 1 NA Ummam… Kõnõ… lyrics-… 1 et välän 1 52 ## 2 1994 1 NA Ummam… Kõnõ… lyrics-… 1 et külm… 2 52 ## 3 1994 1 NA Ummam… Kõnõ… lyrics-… 1 et ja 3 52 ## 4 1994 1 NA Ummam… Kõnõ… lyrics-… 1 et taiv… 4 52 ## 5 1994 1 NA Ummam… Kõnõ… lyrics-… 1 et satas 5 52 ## 6 1994 1 NA Ummam… Kõnõ… lyrics-… 1 et lummõ 6 52 ## 7 1994 1 NA Ummam… Kõnõ… lyrics-… 1 et ütle 7 52 ## 8 1994 1 NA Ummam… Kõnõ… lyrics-… 1 et mullõ 8 52 ## 9 1994 1 NA Ummam… Kõnõ… lyrics-… 1 et uma 9 52 ## 10 1994 1 NA Ummam… Kõnõ… lyrics-… 1 et tele… 10 52 ## # … with 157,622 more rows, and 2 more variables: asukoht &lt;dbl&gt;, ## # asukoht_perc &lt;dbl&gt; Et me kasutame seda korduvalt võime jälle selle salvestada. asukohad &lt;- laulusonad %&gt;% group_by(artist,song,year) %&gt;% mutate(nr=row_number(), n=n()) %&gt;% mutate(asukoht=nr/(n+1)) %&gt;% mutate(asukoht_perc=floor(asukoht*10)/10)%&gt;% ungroup() Ja siis võime näiteks vaadata sõnu, mis palju kordi kordusid. Salvestame selle ka muutujana. kordused &lt;- laulusonad %&gt;% filter(language==&quot;et&quot;) %&gt;% group_by(artist, song,year) %&gt;% count(word,sort=T) %&gt;% filter(!word %in% c(&quot;ref&quot;)) %&gt;% mutate(proportsioon=n/sum(n)) %&gt;% arrange(desc(proportsioon)) %&gt;% ungroup() Võtame 20 kõige enam ühe loo sees korratud sõna ja ühendame selle asukohtade tabeliga nii, et kattuvad nii artist, laul, aasta kui ka sõna. Salvestame selle tulemuse ja vaatame sisse. asukohad_ja_kordused &lt;- kordused %&gt;% filter(row_number()&lt;21) %&gt;% inner_join(asukohad,by=c(&quot;artist&quot;,&quot;song&quot;,&quot;year&quot;,&quot;word&quot;)) Seejärel võime kokku lugeda, et kui palju neid sellel protsendil on. kus_on_kordused &lt;- asukohad_ja_kordused %&gt;% group_by(artist,song,year,word) %&gt;% count(asukoht_perc) Ülalolevast tabelist on küll raske ülevaadet saada, kuna see on pikk rodu numbreid ja mõned on puudu. R-is on tabelite pööramiseks hulk käske, tidyverse-is on selleks pivod_wider() ja pivot_longer(), mis teevad siis vastavalt tabeli laiaks horisontaalskaalal või pikaks vertikaalskaalal. pivot_wider() puhul määrame ära, millised tulbad jäävad nii-öelda paigale, id-tulpadeks, ja millised lahutame lahti. Laotame siis tabeli laiali ja vaatame, kus on need sagedasi korduvad sõnad. kus_on_kordused %&gt;% arrange(asukoht_perc) %&gt;% pivot_wider(id_cols=c(&quot;artist&quot;,&quot;song&quot;,&quot;year&quot;,&quot;word&quot;),names_from=&quot;asukoht_perc&quot;,values_from=&quot;n&quot;) ## # A tibble: 20 x 14 ## # Groups: artist, song, year, word [20] ## artist song year word `0` `0.1` `0.2` `0.3` `0.4` `0.5` `0.6` `0.7` ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Anaco… Veel… 2000 veel 7 8 NA NA NA NA NA 3 ## 2 Beebi… Mend… 2011 mend… 4 8 9 9 10 8 10 5 ## 3 HU? Elup… 2009 ei 1 NA 8 8 1 NA 12 6 ## 4 Kosmi… Öö E… 2011 maga… 2 NA 4 4 1 1 5 5 ## 5 Meie … Sini… 2003 sini… 2 2 2 2 2 4 2 2 ## 6 Meie … Sini… 2003 vilk… 2 2 2 2 2 3 3 2 ## 7 Meie … Sini… 2002 sini… 2 2 2 2 2 4 2 2 ## 8 Meie … Sini… 2002 vilk… 2 2 2 2 2 3 3 2 ## 9 N-Euro Tsak… 1999 tsha… 14 NA 7 7 10 2 5 3 ## 10 Oreli… Valss 2011 laia… 3 2 2 2 2 3 5 2 ## 11 Plane… Sate… 2012 sate… 5 1 5 4 6 1 3 6 ## 12 Push … Musi 2000 musi 3 8 5 7 9 2 4 3 ## 13 Mari-… 1987 2008 o NA 11 1 6 6 12 NA 10 ## 14 Koer Maiu… 2004 maiu NA NA 3 1 NA 2 3 2 ## 15 Koer Maiu… 2004 on NA NA 3 1 NA 2 2 3 ## 16 Koer Maiu… 2004 piim… NA NA 2 2 NA 1 3 3 ## 17 Mikk … Meie… 2015 pa NA NA 4 4 4 4 4 4 ## 18 Gette… Rann… 2014 oo NA NA NA 12 NA NA 12 15 ## 19 The T… Tant… 2000 na NA NA NA NA NA 3 22 11 ## 20 Tuber… Tant… 2001 na NA NA NA NA NA 3 22 11 ## # … with 2 more variables: `0.8` &lt;int&gt;, `0.9` &lt;int&gt; Siit tabelist on näha, et ‘sinine’ ja ‘vilkur’ on Meie Mehe loos Sinine vilkur üsna läbivalt. Samas ‘veel’ Anaconda laulus Veel Veel Veel ainult alguses ja lõpus. Beebilõust räägib ‘mentidest’ läbivalt, sõnad oo ja na on aga ainult laulude lõpus. Nende fraasidega võiks saada proovida läbi teiste lugude ka statistikat koguda. Siin tuleb küll silmas pidada, et laulusõnad on veidi erinevas formaadis ja mõnel neist ei ole korduv refrään taas uuesti kirjutatud, vaid on kasutatud lihtsalt sõna ref uuesti. Et täpsemalt analüüsi tuleks andmeid ka lähemalt ise vaadata. Kui me tahame laia tabeli taas pikaks teha, kasutame funktsiooni pivot_longer(). pivot_longer() tahab teada, milliseid tulpi lahutada ja mis kahe uue tulba nimeks panna. kus_on_kordused %&gt;% arrange(asukoht_perc) %&gt;% ungroup() %&gt;% pivot_wider(id_cols=c(&quot;artist&quot;,&quot;song&quot;,&quot;year&quot;,&quot;word&quot;),names_from=&quot;asukoht_perc&quot;,values_from=&quot;n&quot;) %&gt;% mutate(year=as.character(year)) %&gt;% pivot_longer(cols=starts_with(&quot;0&quot;), names_to=&quot;asukoht_perc&quot;, values_to=&quot;n&quot;) ## # A tibble: 200 x 6 ## artist song year word asukoht_perc n ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Anaconda Veel Veel Veel 2000 veel 0 7 ## 2 Anaconda Veel Veel Veel 2000 veel 0.1 8 ## 3 Anaconda Veel Veel Veel 2000 veel 0.2 NA ## 4 Anaconda Veel Veel Veel 2000 veel 0.3 NA ## 5 Anaconda Veel Veel Veel 2000 veel 0.4 NA ## 6 Anaconda Veel Veel Veel 2000 veel 0.5 NA ## 7 Anaconda Veel Veel Veel 2000 veel 0.6 NA ## 8 Anaconda Veel Veel Veel 2000 veel 0.7 3 ## 9 Anaconda Veel Veel Veel 2000 veel 0.8 7 ## 10 Anaconda Veel Veel Veel 2000 veel 0.9 6 ## # … with 190 more rows Proovi ise! Vali mõni lugu ja sõna selles ning vaata, mis asukohtadel ta esineb. #--------------------------------------------- #--------------------------------------------- 5.7 Sõnastik %&gt;% - vii andmed järgmisesse protsessi unnest_tokens() - võtab tekstijupi ja jupitab selle mingil alusel ja paneb iga jupi eraldi reale. left_join() - liidab vasakpoolse andmestiku külge need read, mis sobivad paremast. right_join() - liidab parempoolse andmestiku külge need read, mis sobivad vasakust. inner_join() - jätab alles ainult sobivad read kummastki full_join() - jätab alles kõik read mõlemast tabelist, isegi kui ükski ei kattu. anti_join() - töötab vastupidiselt ja eemaldab vasakust kõik read, mis ühtivad parempoolse tabeliga. group_by() - grupeeri andmestik mõne tunnuse alusel ungroup() - vii andmestik grupeerimata kujule pivot_wider() - vii tabel laiaks pivot_longer() - vii tabel pikak 5.8 Harjutusülesanded Millised olid levinuimad sõnad Vaiko Epliku sõnavaras? Millised olid levinuimad sõnad Vaiko Epliku sõnavaras kui eemaldada ka stopsõnad? Milline oli levikult kolmeteistkümnes sõna kõigis eestikeelsetes tekstides? Mitu sõna esines kõigil 25-l aastal? Leia sõnad, mida korrati kõige rohkem laulu teises pooles. "],
["mitmikud-regulaaravaldised-ja-märksõnad.html", "Peatükk 6 Mitmikud, regulaaravaldised ja märksõnad 6.1 Bigrammid 6.2 Valimi parandamine 6.3 Regulaaravaldised 6.4 Trigrammid 6.5 Märksõnade leidmine 6.6 Sõnastik 6.7 Harjutusülesanded", " Peatükk 6 Mitmikud, regulaaravaldised ja märksõnad Selles peatükis vaatame, kuidas saab tidyverse ja tidytext pakettide abil töötada sõnamitmikega, kasutada regulaaravaldisi otsingutes ning leida märksõnu, mis iseloomustavad mõnd teksti või tekstidegruppi. Kui me käivitasime just R-i, siis alustame jälle pakettide käivitamisest. library(tidyverse) library(tidytext) Samuti vajame me taaskord andmestikku. Veenduge, et töökataloog on määratud õigesse kohta. edetabel &lt;- read_tsv(&quot;data/eesti_top40/eesti_skyplus_top40_1994-2018.tsv&quot;) ## Parsed with column specification: ## cols( ## year = col_double(), ## rank = col_double(), ## votes = col_double(), ## artist = col_character(), ## song = col_character(), ## filename = col_character(), ## source = col_double(), ## lyrics = col_character(), ## language = col_character() ## ) 6.1 Bigrammid Eelmises peatükis kasutasime unnest_tokens() funktsiooni, et lahutada tabelis olevaid tekste sõnapikkusteks üksusteks. Nagu teised funktsioonis R-is on ka unnest_tokens() mõneti paindlik ja sellega saab teha veidi teistsuguseid asju, muutes selle parameetreid. Kasutame küsimärki ? käsu ees, et saada liig selle abifailile. Käsu käivitamine avab abiteksti paremal all ja näitab seda failide asemel. Failide ja abiteksti vahel saab liikuda selle akna menüüs (siis vastavalt Help ja Files sälgud). ?unnest_tokens Abikäsk näitab käsu sisu, näiteid ja parameetreid, mida saab selles muuta. unnest_tokens(tbl, output, input, token = &quot;words&quot;, format = c(&quot;text&quot;, &quot;man&quot;, &quot;latex&quot;, &quot;html&quot;, &quot;xml&quot;), to_lower = TRUE, drop = TRUE, collapse = NULL, ...) Esimene neist parameetritest on see, millele annab sisendi %&gt;% toru käsk tidyverse töötluses. Antud juhul siis tbl, mis on sisendtabel. Enamasti ongi vaikimisi esimene sisend just andmestik, millega töötatakse. Parameetreid võib määrata järjekorra järgi, või andes ette parameetri nime. Näiteks unnest_tokens(word,text) on sama kui unnest_tokens(output=word, input=text) juhul kui alustabel tbl on söödetud käsu eestpoolt ja toruga. Funktsioonil on aga veel parameetreid. Kõik parameetrid, millel on antud abifailis võrdusmärgiga = vaste, on parameetrid, millel on olemas vaikimisi väärtus. Ehk, kui me ise just teisiti ei määra, kasutab programm käsu vaikeväärtust. Vaikimisi võtab programm sõna ühikuks token = “words”. Samuti määrab ta vaikimisi, et to_lower = TRUE, misläbi muudetakse kõik suurtähed väiketähtedeks ja drop = TRUE, misläbi eemaldatakse sõnade leidmise aluseks olnud tulp. Kõikide parameetrite seletus on antud abifailis veidi allpool. Vaadates lähemalt token parameetrit näeme, et sellel on hulga variante: “words” (vaikimisi), “characters”, “character_shingles”, “ngrams”, “skip_ngrams”, “sentences”, “lines,”paragraphs, “regex”, “tweets”, “ptb”. Meil ei ole neid kõiki praegu vaja, aga võime proovida varianti ngrams ehk mitmikud. Meenutuseks, et eelmises õppetükis tegime sellise tabeli. Me võime seal eraldi märkida, et token = “words”, aga me võime selle ka ära jätta, kuna “words” on seal antud juhul vaikeväärtus. edetabel %&gt;% unnest_tokens(word, lyrics, token = &quot;words&quot;) ## # A tibble: 157,632 x 9 ## year rank votes artist song filename source language word ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et välän ## 2 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et külmetas ## 3 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et ja ## 4 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et taivast ## 5 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et satas ## 6 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et lummõ ## 7 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et ütle ## 8 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et mullõ ## 9 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et uma ## 10 1994 1 NA Ummamuu… Kõnõtr… lyrics-ummamuud… 1 et telefoni… ## # … with 157,622 more rows Samas nägime abifailist, et seda võib ka muuta. Asetame siis selleks “ngrams”. Kui väärtuseks on määratud “ngrams”, siis me peame omakorda määrama selles lisaparameetreid. Nimelt soovib käsk teada, kui suuri mitmikuid me soovime. Määratleme minimaalse suuruse n_min = 2 ja maksimaalse suuruse n = 2. Sellisel juhul teeb unnest_tokens() sõnade tabeli asemel bigrammide tabeli. edetabel %&gt;% unnest_tokens(bigram, lyrics, token = &quot;ngrams&quot;, n = 2, n_min = 2) ## # A tibble: 156,810 x 9 ## year rank votes artist song filename source language bigram ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1994 1 NA Ummamuu… Kõnõt… lyrics-ummamuu… 1 et välän külm… ## 2 1994 1 NA Ummamuu… Kõnõt… lyrics-ummamuu… 1 et külmetas ja ## 3 1994 1 NA Ummamuu… Kõnõt… lyrics-ummamuu… 1 et ja taivast ## 4 1994 1 NA Ummamuu… Kõnõt… lyrics-ummamuu… 1 et taivast sa… ## 5 1994 1 NA Ummamuu… Kõnõt… lyrics-ummamuu… 1 et satas lummõ ## 6 1994 1 NA Ummamuu… Kõnõt… lyrics-ummamuu… 1 et lummõ ütle ## 7 1994 1 NA Ummamuu… Kõnõt… lyrics-ummamuu… 1 et ütle mullõ ## 8 1994 1 NA Ummamuu… Kõnõt… lyrics-ummamuu… 1 et mullõ uma ## 9 1994 1 NA Ummamuu… Kõnõt… lyrics-ummamuu… 1 et uma telefo… ## 10 1994 1 NA Ummamuu… Kõnõt… lyrics-ummamuu… 1 et telefoninu… ## # … with 156,800 more rows Proovime mängida parameetritega. Näiteks võime käsu sees määratleda ka et mitmike pikkus peaks olema ühest kolmeni. Sellisel juhul näitab käsk kõiki võimalikke mitmike suurusega ühest kolmeni, ehk nii sõnu, bigramme kui trigramme. edetabel %&gt;% unnest_tokens(bigram, lyrics, token = &quot;ngrams&quot;, n = 3, n_min = 1) ## # A tibble: 470,074 x 9 ## year rank votes artist song filename source language bigram ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1994 1 NA Ummamuu… Kõnõt… lyrics-ummamuu… 1 et välän ## 2 1994 1 NA Ummamuu… Kõnõt… lyrics-ummamuu… 1 et välän külm… ## 3 1994 1 NA Ummamuu… Kõnõt… lyrics-ummamuu… 1 et välän külm… ## 4 1994 1 NA Ummamuu… Kõnõt… lyrics-ummamuu… 1 et külmetas ## 5 1994 1 NA Ummamuu… Kõnõt… lyrics-ummamuu… 1 et külmetas ja ## 6 1994 1 NA Ummamuu… Kõnõt… lyrics-ummamuu… 1 et külmetas j… ## 7 1994 1 NA Ummamuu… Kõnõt… lyrics-ummamuu… 1 et ja ## 8 1994 1 NA Ummamuu… Kõnõt… lyrics-ummamuu… 1 et ja taivast ## 9 1994 1 NA Ummamuu… Kõnõt… lyrics-ummamuu… 1 et ja taivast… ## 10 1994 1 NA Ummamuu… Kõnõt… lyrics-ummamuu… 1 et taivast ## # … with 470,064 more rows Võtame siis ette bigrammid. Et meil on tabelit korduvalt vaja ning selle tekitamine võtab hetk aega, salvestame selle tulemuse jälle muutujasse. bigrams &lt;- edetabel %&gt;% unnest_tokens(bigram, lyrics, token = &quot;ngrams&quot;, n = 2, n_min = 2) Samamoodi kui sõnadest, saame me teha ka bigrammidest sagedustabeli. Levinud fraasid on ikka samad kui keeles ikka ‘ei saa’, ‘ei ole’, ‘ei tea’, ‘ma ei’, ‘ma olen’, ‘mul on’. bigrams %&gt;% count(bigram,sort=T) ## # A tibble: 76,888 x 2 ## bigram n ## &lt;chr&gt; &lt;int&gt; ## 1 ei saa 357 ## 2 ma ei 356 ## 3 see on 241 ## 4 ei ole 204 ## 5 &lt;NA&gt; 178 ## 6 ei tea 165 ## 7 na na 165 ## 8 on see 160 ## 9 ma olen 145 ## 10 mul on 138 ## # … with 76,878 more rows Nagu sai näidatud varasemates peatükkides saame loendada mitu tunnust korraga. Seeläbi saame näiteks kokku lugeda fraasikordusi ühes laulus. Näiteks na na, oo oo ja ba da on väga populaarsed fraasid. bigrams %&gt;% count(bigram,song,sort=T) ## # A tibble: 99,430 x 3 ## bigram song n ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 na na Tantsin valssi 68 ## 2 na na Tantsin Valssi 68 ## 3 vesi peale Vesi peale 56 ## 4 oo oo Rannamaja 50 ## 5 ba da Musi 48 ## 6 jalas polnud Peegelpõrand 48 ## 7 polnud pükse Peegelpõrand 48 ## 8 armastus on Armastus On Armastus 47 ## 9 pappi ei Pankrot 46 ## 10 and i Pictures 43 ## # … with 99,420 more rows Samas näeme sellega ära, et meie andmestik on veidi ebamugav selle kohta pealt, et mõni laul on seal mitu korda. Ja samas või selle laulu nimi olla sama või erinev. Kui me nüüd loendame ainult fraasi ja laulunime järgi, siis võib mõni lugu saada seal mitmekordsed numbrid, kuna laul justkui oleks kaks korda nii pikk kui ta on. Teisest küljest, me saame ühest ‘Tantsin valssi’ loost kätte juba info na na kohta, me ei pea seda kaks korda nägema. Kui me loendame laulu, artisti ja aasta kombinatsioone, siis tabel juba mõneti muutubki. Näiteks “jalas polnud” ja “polnud pükse” kaovad edetabelist ära, kuna Peegelpõranda laul oli tabelis kaks aastat, mistõttu olid sõnasagedused leotud topelt. bigrams %&gt;% count(bigram,song,artist,year,sort=T) ## # A tibble: 105,352 x 5 ## bigram song artist year n ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 na na Tantsin valssi Tuberkuloited &amp; Urmas Voolpriit 2001 68 ## 2 na na Tantsin Valssi The Tuberkuloited 2000 68 ## 3 vesi peale Vesi peale N-Euro 2000 56 ## 4 oo oo Rannamaja Getter Jaani ja Koit Toome 2014 50 ## 5 ba da Musi Push Up 2000 48 ## 6 armastus on Armastus On Armastus Külalised 2008 47 ## 7 pappi ei Pankrot Toe Tag 2005 46 ## 8 and i Pictures Ewert And The Two Dragons 2014 43 ## 9 ei saagi Pankrot Toe Tag 2005 42 ## 10 võid nii Estonian business Suur Papa 2013 42 ## # … with 105,342 more rows 6.2 Valimi parandamine Me võime võtta nüüd selle arvesse ja püüda meie valimit varasemate teadmiste põhjal parandada. Nimelt, me teame, et mõnikord võib olla pealkiri sama, kuid erineda väike ja suurtähtedelt ning me teame, et mõned lood on tabelis mitu aastat ehk mitu korda. Me saame aga oma tabelit muuta selle järgi. mutate() käsule saame anda sisendiks, et ta viiks tulbad väiketähtede kujule. Selleks on funktsioon tolower(). Ja me saame grupeerida ja filtreerida andmsetikku nii, et iga artisti ja laulu kombinatsiooni kohta jääb alles ainult esimene aasta. edetabel %&gt;% mutate(artist=tolower(artist),song=tolower(song)) %&gt;% group_by(artist,song) %&gt;% filter(year==min(year)) ## # A tibble: 947 x 9 ## # Groups: artist, song [946] ## year rank votes artist song filename source lyrics language ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1994 1 NA ummamuu… kõnõtr… lyrics-umma… 1 &quot;:,:Välän kü… et ## 2 1994 2 NA vennask… pille-… lyrics-venn… 1 &quot;Taevas sine… et ## 3 1994 3 NA jam see 5 lyrics-jam-… 1 &quot;See viis ha… et ## 4 1994 4 NA the tub… lillek… lyrics-the_… 1 &quot;Tüdruk vaat… et ## 5 1994 5 NA the tub… põhjam… lyrics-the_… 1 &quot;Kui käes on… et ## 6 1994 6 NA jam su jär… lyrics-jam-… 1 &quot;Enne sind e… et ## 7 1994 7 NA 2 quick… olen l… lyrics-2_qu… 1 &quot;1. PÕHJUST … et ## 8 1994 8 NA termina… torm lyrics-term… 1 &quot;Olen tulnud… et ## 9 1994 9 NA 2 quick… sinu j… lyrics-2_qu… 1 &quot;1. EKSISIN … et ## 10 1994 10 NA d-gän seib lyrics-d-ga… 1 &quot;ELASID KOOS… et ## # … with 937 more rows Niimoodi andmestikku muutes, saame kokku kokku 947 erinevat lugu eelmise 1000 asemel. Salvestame selle tabeli nime all firstsongs. Grupeeriv faktor tasub salvestades enamasti lahti siduda, kuna mõned funktsioonid nõuavad grupeerimata andmestikku või muutuvad väga aeglaseks siis, kui andmestik on tehtud paljudeks gruppideks. firstsongs &lt;- edetabel %&gt;% mutate(artist=tolower(artist),song=tolower(song)) %&gt;% group_by(artist,song) %&gt;% filter(year==min(year)) %&gt;% ungroup() # Kõige lõpus tasub grupid lahti siduda Salvestatud puhastatud tabelit saame kasutada nüüd sisendina edasiseks analüüsiks. Leiame uuesti bigrammid tekstide seast ning salvestame need vana muutuja asemele. bigrams &lt;-firstsongs %&gt;% mutate(artist=tolower(artist),song=tolower(song)) %&gt;% group_by(artist,song) %&gt;% filter(year==min(year))%&gt;% ungroup() %&gt;% unnest_tokens(bigram, lyrics, token = &quot;ngrams&quot;, n = 2, n_min = 2) Samuti nagu varem võime nüüd loendada bigramme laulude kohta. Seekord aga ei pea vaatama, mis aastaga tegemist on ja paljud kordused on nüüd kadunud. On muidugi lugusid, millel artisti või laulu nimi erineb aasta-aastalt veidi rohkem kui ainult suurtähtede ja väiketähtede kaudu - näiteks seesama tantsin valssi, mille artist on muutunud. Aga paljuski saame me nii juba täpsema info. Et kõik sama loo erinevad variandid saaks eemaldatud, tuleb veel täpsemalt proovida artisti nimesid ühitada. Praegu piirdume suur- ja väiketähtedega. bigrams %&gt;% count(bigram,song,artist,sort=T) ## # A tibble: 98,793 x 4 ## bigram song artist n ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 na na tantsin valssi the tuberkuloited 68 ## 2 na na tantsin valssi tuberkuloited &amp; urmas voolpriit 68 ## 3 vesi peale vesi peale n-euro 56 ## 4 oo oo rannamaja getter jaani ja koit toome 50 ## 5 ba da musi push up 48 ## 6 armastus on armastus on armastus külalised 47 ## 7 pappi ei pankrot toe tag 46 ## 8 and i pictures ewert and the two dragons 43 ## 9 ei saagi pankrot toe tag 42 ## 10 võid nii estonian business suur papa 42 ## # … with 98,783 more rows 6.3 Regulaaravaldised Nagu varem sõnadega, võime me filtreerida seda tabelit ka fraasi kaupa. Näiteks ‘ei saa’ esinemised eri lauludes saame kätte niiviisi. Päris paljudes lauludes kordub fraas ‘ei saa’ mitmeid kordi. Tähele võib panna, et sellisel juhul on aga oluline, et fraas oleks täpselt selline nagu on kirjeldatud. bigrams %&gt;% count(bigram,song,sort=T) %&gt;% filter(bigram==&quot;ei saa&quot;) ## # A tibble: 149 x 3 ## bigram song n ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 ei saa jagatud saladus 17 ## 2 ei saa tahan elada 14 ## 3 ei saa kesköödisko 9 ## 4 ei saa teine kadriorg 9 ## 5 ei saa sinise leegiga 8 ## 6 ei saa kallis 7 ## 7 ei saa lähedal 6 ## 8 ei saa miks ainult mõni asi on nii hea 6 ## 9 ei saa väike saatan 6 ## 10 ei saa pankrot 5 ## # … with 139 more rows Me teame varem koostatud sõnaloendite põhjal, et sõna ‘ei’ on neis tekstides üldse sage. Kui me nüüd tahaks teada, millises kontekstis sõna ‘ei’ esineb, ei saa me ette kirjutada kõiki eri variante. Sellisel puhul on meil võimalik kasutada käske tekstiosade kattuvuseks ning regulaaravaldisi. Tidyverse pakettides on ka tekstidega töötamiseks eraldi osa stringr, kus on meid aitavad kaks funktsiooni str_detect(), mis kontrollib, kas tekstis sisaldub ettekirjutatud jupp ja str_extract(), mis eraldab kirjutatud jupi tekstist. str_detect(muutuja, “sõne”) - kontrolli, kas tekstis esineb selline järjend str_extract(muutuja, “sõne”) - leia selline järjend tekstis ning esita leitud järjend Need funktsioonid võtavad sisendina vaikimisi regulaaravaldisi, mis avardab meie otsimisvõimekust oluliselt. Otsides ainult järjendit ‘ei saa’ leiame, et meie esialgne otsing ei leidnud varianti, ei saagi, mida kordub ühe loo sees isegi kõige rohkem. Nimelt läheb edetabeli tippu toe tag pankrott, kus fraas ‘ei saagi’ esineb suisa 42 korda. Kuivõrd ta on tähenduselt üsna sarnane, siis on seda meilgi ehk oluline teada. bigrams %&gt;% count(bigram,song,sort=T) %&gt;% filter(str_detect(bigram,&quot;ei saa&quot;)) ## # A tibble: 177 x 3 ## bigram song n ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 ei saagi pankrot 42 ## 2 ei saa jagatud saladus 17 ## 3 ei saa tahan elada 14 ## 4 ei saa kesköödisko 9 ## 5 ei saa teine kadriorg 9 ## 6 ei saa sinise leegiga 8 ## 7 ei saa kallis 7 ## 8 ei saa lähedal 6 ## 9 ei saa miks ainult mõni asi on nii hea 6 ## 10 ei saa väike saatan 6 ## # … with 167 more rows Me võime ka otsida kõiki sarnaseid fraase, mis algavad eitusega. Selleks otsime sõna ei, millele järgneb tühik ja siis ükskõik milline tähekombinatsioon. Ja saame, et neid eitavas vormides fraase on lugude seas veel. ei-ei, ei saa, ei hooli, ei pea, ei huvita ei lase, jne. bigrams %&gt;% count(bigram,song,sort=T) %&gt;% filter(str_detect(bigram,&quot;ei [a-zõäöü]+&quot;)) ## # A tibble: 1,607 x 3 ## bigram song n ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 ei saagi pankrot 42 ## 2 ei ei elupõletaja 36 ## 3 ei saa jagatud saladus 17 ## 4 ei hooli mälestused 16 ## 5 ei pea ei pea iial 15 ## 6 ei huvita elupõletaja 14 ## 7 ei lase öö ei lase magada 14 ## 8 ei saa tahan elada 14 ## 9 ei ole võta aega 12 ## 10 ei tagasi teine kadriorg 12 ## # … with 1,597 more rows Teine viis leida kõik fraasid, mis algavad sõnaga ei, on kasutada regulaaravaldiste teksti alguse tähist ^. Nii teab käsk, et ‘ei’ peab olema fraasi alguses. bigrams %&gt;% count(bigram,song,sort=T) %&gt;% filter(str_detect(bigram,&quot;^ei &quot;)) ## # A tibble: 1,553 x 3 ## bigram song n ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 ei saagi pankrot 42 ## 2 ei ei elupõletaja 36 ## 3 ei saa jagatud saladus 17 ## 4 ei hooli mälestused 16 ## 5 ei pea ei pea iial 15 ## 6 ei huvita elupõletaja 14 ## 7 ei lase öö ei lase magada 14 ## 8 ei saa tahan elada 14 ## 9 ei ole võta aega 12 ## 10 ei tagasi teine kadriorg 12 ## # … with 1,543 more rows Tõtt-öelda bigrammidega piisab ka tühikust, kuna neis on tühik alati esimesest sõnast paremal. bigrams %&gt;% count(bigram,song,sort=T) %&gt;% filter(str_detect(bigram,&quot;ei &quot;)) ## # A tibble: 1,610 x 3 ## bigram song n ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 ei saagi pankrot 42 ## 2 ei ei elupõletaja 36 ## 3 ei saa jagatud saladus 17 ## 4 ei hooli mälestused 16 ## 5 ei pea ei pea iial 15 ## 6 ei huvita elupõletaja 14 ## 7 ei lase öö ei lase magada 14 ## 8 ei saa tahan elada 14 ## 9 ei ole võta aega 12 ## 10 ei tagasi teine kadriorg 12 ## # … with 1,600 more rows Võime proovida otsida ka näiteks sidesõnale ja järgnevaid sõnu. bigrams %&gt;% count(bigram,song,sort=T) %&gt;% filter(str_detect(bigram,&quot;ja [a-zõäöü]+&quot;)) ## # A tibble: 2,624 x 3 ## bigram song n ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 ja ma lase mul olla mina 14 ## 2 russkaja vodka russkaja vodka 14 ## 3 ja loodame jää 13 ## 4 ja me pankrot 13 ## 5 vaja kedagi vihmapiisad päikest täis 13 ## 6 ja kõik küsin endalt nõu 12 ## 7 ja ma ma vaid palun 12 ## 8 ja nooled pilgud ja nooled 12 ## 9 ja pole pole sinu asi 12 ## 10 ja silmad su hääl su suu ja silmad 12 ## # … with 2,614 more rows Me võime otsida sedasi ükskõik mida. bigrams %&gt;% count(bigram,song,sort=T) %&gt;% filter(str_detect(bigram,&quot;ma &quot;)) ## # A tibble: 2,633 x 3 ## bigram song n ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 oma valu ehitaja 19 ## 2 ma lähen sinu ees 18 ## 3 ma tahan ma tahan sind. sa vajad mind 16 ## 4 ma šokolaadist šokolaadist jänes 14 ## 5 umma tshaka tsaka-tsaka 14 ## 6 umma umma tsaka-tsaka 14 ## 7 ma ei täna me ei skoori 13 ## 8 ma lähen mõtetes mõrudais 13 ## 9 ilma okasteta okkaline lill 12 ## 10 kuuma kuuma maia 12 ## # … with 2,623 more rows bigrams %&gt;% count(bigram,song,sort=T) %&gt;% filter(str_detect(bigram,&quot;jama[ a-zõäöü]+&quot;)) ## # A tibble: 48 x 3 ## bigram song n ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 mu põhjamaa põhjamaa neid 12 ## 2 põhjamaa neid põhjamaa neid 12 ## 3 ajamasin kaasa 1987 5 ## 4 viib ajamasin 1987 5 ## 5 õllele turjamaale vihma loits 4 ## 6 turjamaale õlle vihma loits 4 ## 7 varjama ei sinu jaoks 2 ## 8 18 ajamasin jälle 18 1 ## 9 ajama ju eestlased 1 ## 10 ajama pean veel veel veel 1 ## # … with 38 more rows Proovige leida nüüd kõik fraasid, mis sisaldavad eestit ükskõik, mis kujul #--------------------------------------------- #--------------------------------------------- Teine küsimus, kus regulaaravaldised kuluvad eriti ära, on kui me tahame teada saada teatud sõnavormide kohta. Näiteks meid huvitavad kõik armastusega seotud sõnad neis lauludes. Võime teha otsingu, mis hõlmaks ‘armastus’, ‘armastama’ ja selle vorme. Nii saame kätte kõik fraasid, kus on sellest mingil määral juttu. bigrams %&gt;% count(bigram,song,sort=T) %&gt;% filter(str_detect(bigram,&quot;armast[ua]&quot;)) ## # A tibble: 223 x 3 ## bigram song n ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 armastus on armastus on armastus 47 ## 2 on armastus armastus on armastus 14 ## 3 armastus armastus armastus on armastus 13 ## 4 tunde armastus armastus on armastus 10 ## 5 yo armastus armastus on armastus 10 ## 6 armastan ma kas tead 8 ## 7 flow armastus armastus on armastus 7 ## 8 armastanud kaua kaks meeste 6 ## 9 polnud armastanud kaks meeste 6 ## 10 armastuses ja väike valge vale 5 ## # … with 213 more rows Kui me aga tahame küsida sõna eri vormide kohta, võime me leidude vasted uude tabeli tulpa panna. str_extract() võtab tekstist välja täpselt sellise vormi, mis me leidsime. bigrams %&gt;% count(bigram,song,sort=T) %&gt;% filter(str_detect(bigram,&quot;armast[ua]&quot;)) %&gt;% mutate(vorm=str_extract(bigram,&quot;armast[ua]&quot;)) ## # A tibble: 223 x 4 ## bigram song n vorm ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; ## 1 armastus on armastus on armastus 47 armastu ## 2 on armastus armastus on armastus 14 armastu ## 3 armastus armastus armastus on armastus 13 armastu ## 4 tunde armastus armastus on armastus 10 armastu ## 5 yo armastus armastus on armastus 10 armastu ## 6 armastan ma kas tead 8 armasta ## 7 flow armastus armastus on armastus 7 armastu ## 8 armastanud kaua kaks meeste 6 armasta ## 9 polnud armastanud kaks meeste 6 armasta ## 10 armastuses ja väike valge vale 5 armastu ## # … with 213 more rows Selleks, et saada tervet sõna, peame regulaaravaldist pikendama, et ta võtaks kaasa kõik tähestiku tähed, aga mitte tühikud. bigrams %&gt;% count(bigram,song,sort=T) %&gt;% filter(str_detect(bigram,&quot;armast[ua]&quot;)) %&gt;% mutate(vorm=str_extract(bigram,&quot;armast[ua][a-zõäöü]+&quot;)) ## # A tibble: 223 x 4 ## bigram song n vorm ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; ## 1 armastus on armastus on armastus 47 armastus ## 2 on armastus armastus on armastus 14 armastus ## 3 armastus armastus armastus on armastus 13 armastus ## 4 tunde armastus armastus on armastus 10 armastus ## 5 yo armastus armastus on armastus 10 armastus ## 6 armastan ma kas tead 8 armastan ## 7 flow armastus armastus on armastus 7 armastus ## 8 armastanud kaua kaks meeste 6 armastanud ## 9 polnud armastanud kaks meeste 6 armastanud ## 10 armastuses ja väike valge vale 5 armastuses ## # … with 213 more rows Ja nüüd võime omakorda kokku lugeda, mis vormides need sõnad olid bigrams %&gt;% count(bigram,song,sort=T) %&gt;% filter(str_detect(bigram,&quot;armast[ua]&quot;)) %&gt;% mutate(vorm=str_extract(bigram,&quot;armast[ua]([a-zõäöü]+)?&quot;)) %&gt;% count(vorm,sort=T) ## # A tibble: 21 x 2 ## vorm n ## &lt;chr&gt; &lt;int&gt; ## 1 armastus 66 ## 2 armastan 39 ## 3 armastust 30 ## 4 armastad 18 ## 5 armastuse 16 ## 6 armasta 14 ## 7 armastada 8 ## 8 armastab 6 ## 9 armastades 2 ## 10 armastama 2 ## # … with 11 more rows Samamoodi võime võtta näiteks välja kõik sõnad, mis järgnevad sõnale armastus, ükskõik, mis vormis. Lisame otsingule sõna alguse tähise, ning võtame välja kõik, mis järgneb tühikule. Nagu arvata oli on ikka kõige sagedasemad vormid muidu ka levinud sõnad. Samas pidagem meeles, et praegu me vaatasime, mitmes laulus need fraasid on. Me võime ka vaadata mitu korda fraase esineb kokku. bigrams %&gt;% count(bigram,song,sort=T) %&gt;% filter(str_detect(bigram,&quot;^armast[ua]&quot;)) %&gt;% mutate(vorm=str_extract(bigram,&quot; [a-zõäöü]+&quot;)) %&gt;% count(vorm,sort=T) ## # A tibble: 69 x 2 ## vorm n ## &lt;chr&gt; &lt;int&gt; ## 1 &quot; ja&quot; 10 ## 2 &quot; sind&quot; 6 ## 3 &quot; ma&quot; 5 ## 4 &quot; on&quot; 5 ## 5 &quot; mind&quot; 4 ## 6 &quot; ei&quot; 3 ## 7 &quot; kuid&quot; 3 ## 8 &quot; nii&quot; 3 ## 9 &quot; käib&quot; 2 ## 10 &quot; kui&quot; 2 ## # … with 59 more rows Tidyverse %&gt;% märgiga kirjutatud koodis on selleks hea võimalus. Me võime lihtsalt mõne käsu välja kommenteerida # trellidega. bigrams %&gt;% #count(bigram,song,sort=T) %&gt;% filter(str_detect(bigram,&quot;^armast[ua]&quot;)) %&gt;% mutate(vorm=str_extract(bigram,&quot; [a-zõäöü]+&quot;)) %&gt;% count(vorm,sort=T) ## # A tibble: 69 x 2 ## vorm n ## &lt;chr&gt; &lt;int&gt; ## 1 &quot; on&quot; 52 ## 2 &quot; ja&quot; 16 ## 3 &quot; ma&quot; 15 ## 4 &quot; armastus&quot; 13 ## 5 &quot; sind&quot; 9 ## 6 &quot; kaua&quot; 6 ## 7 &quot; kuid&quot; 5 ## 8 &quot; mind&quot; 5 ## 9 &quot; tunda&quot; 5 ## 10 &quot; kui&quot; 4 ## # … with 59 more rows Proovige leida, mis vormides ‘eesti’ lauludes esineb. #--------------------------------------------- #--------------------------------------------- 6.4 Trigrammid Sarnaselt bigrammidele saame unnest_tokens() parameetreid sättides võtta tekstidest välja ka trigrammid. trigrams &lt;- firstsongs %&gt;% unnest_tokens(trigram, lyrics, token = &quot;ngrams&quot;, n = 3, n_min = 3) Võime neid samuti loendada. trigrams %&gt;% count(trigram,sort=T) ## # A tibble: 99,130 x 2 ## trigram n ## &lt;chr&gt; &lt;int&gt; ## 1 &lt;NA&gt; 177 ## 2 na na na 142 ## 3 ma ei saa 60 ## 4 o o o 53 ## 5 oh oh oh 51 ## 6 oo oo oo 45 ## 7 la la la 44 ## 8 pappi ei saagi 42 ## 9 me pappi ei 41 ## 10 veel ja veel 41 ## # … with 99,120 more rows Ja võime ka nende kordusi loendada. trigrams %&gt;% group_by(artist,song) %&gt;% count(trigram,sort=T) ## # A tibble: 103,823 x 4 ## # Groups: artist, song [946] ## artist song trigram n ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 the tuberkuloited tantsin valssi na na na 64 ## 2 tuberkuloited &amp; urmas voolpriit tantsin valssi na na na 64 ## 3 toe tag pankrot pappi ei saagi 42 ## 4 toe tag pankrot me pappi ei 41 ## 5 getter jaani ja koit toome rannamaja oo oo oo 40 ## 6 kerli army of love love to love 40 ## 7 cool d kas sa kuuled kas sa kuuled 30 ## 8 suur papa estonian business nii faking teha 30 ## 9 suur papa estonian business võid nii faking 30 ## 10 vanilla ninja liar oh oh oh 28 ## # … with 103,813 more rows Kombineerides olemasolevaid käske võime nüüd näiteks otsida välja kõik fraasid, kus esineb sama sõna nii alguses kui lõpus. Me teame, et ^ märk tähistab rea algust ja et $ märk tähistab rea lõppu (vaata regulaaravaldiste juhendit moodle-is). Kui me nüüd võtame välja antud tabelist kõik esimesed ja viimased sõnad ja filtreerime välja ainult read, kus need on sama sõna, saamegi kätte oodatud tulemuse. Päris suur hulk fraase on sellist, kus on sees selline sõnakordus. trigrams %&gt;% group_by(artist,song) %&gt;% count(trigram,sort=T) %&gt;% mutate(firstw=str_extract(trigram,&quot;^[a-zõäöü]+&quot;),lastw=str_extract(trigram,&quot;[a-zõäöü]+$&quot;)) %&gt;% filter(firstw==lastw) ## # A tibble: 1,125 x 6 ## # Groups: artist, song [445] ## artist song trigram n firstw lastw ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 the tuberkuloited tantsin v… na na na 64 na na ## 2 tuberkuloited &amp; urm… tantsin v… na na na 64 na na ## 3 getter jaani ja koi… rannamaja oo oo oo 40 oo oo ## 4 kerli army of l… love to love 40 love love ## 5 vanilla ninja liar oh oh oh 28 oh oh ## 6 dagö välismaa pool anna pool 26 pool pool ## 7 planeet satelliid… satelliidid satellii… 26 satelli… satelli… ## 8 dagö välismaa anna pool anna 24 anna anna ## 9 hu? elupõleta… ei ei ei 24 ei ei ## 10 n-euro vesi peale peale vesi peale 24 peale peale ## # … with 1,115 more rows Keskmise sõna saaks kätte otsides sõnaäärseid tühikuid str_extract(trigram, &quot; [a-zõäöü]+ &quot;). Olles eraldanud sõna eraldi tulpa, võime sama tulpa käsitleda ka tekstina järgmisteks operatsioonideks. Kasutades olemasolevat informatsiooni, leia kõik fraasid, kus kõik kolm sõna on täpselt samad. #--------------------------------------------- #--------------------------------------------- 6.5 Märksõnade leidmine Siiani oleme püüdnud leida tekstist meid huvitavaid sõnu eemaldades ebahuvitavad stopsõnad või otsides konkreetseid fraase, mis meile silma jäävad. Tekstitöötluses on üpris palju eri meetodeid ka selleks, et püüda välja arvutada huvitavad sõnad või fraasid mõne teksti kohta. Antconc-is sai seda teha märksõnaotsingu alusel - mida suurem keyness väärtus märksõnal oli, seda rohkem ta oli eriline sellele tekstile. Üks viis selliseid märksõnu leida, mis on ka tidytext paketti sisse kirjutatud on tf-idf, see tähendab term frequency - inverse document frequency. Loe täpsemat sisu siit https://en.wikipedia.org/wiki/Tf-idf. Selle valemi aluseks on vaist, et kui sõna on sage ühes dokumendis, aga seda teistes tekstides tihti ei leidu, võiks seda pidada seda teksti eristavaks teistest ehk selle teksti märksõnaks. Selle arvutamiseks loetakse kokku kui palju on üht sõna konkreetses tekstis või tekstide kogumis ning korrutatakse läbi arvuga, mis iseloomustab kui paljudes tekstides seda on. Erinevaid variante sellest valemist on mitmeid ja see, milline neist on sobivaim konkreetse küsimuse lahendamiseks võib sõltuda korpuse suurusest, iseloomust või küsimusest endast. Üldjoontes annavad enamik neist mõistlikke tulemusi. Niisiis, sõna, mis on üldiselt korpuses haruldane, aga sage selles tekstis on sõna, võiks olla selle teksti jaoks eristavaks märksõnaks. Sõnad, mida on palju kõikides tekstides ei erista seda teksti teistest. Samas sõnad, mis on eriti sagedased ühes tekstis võivad siiski osutuda märksõnadeks isegi kui neid on paljudes muudes tekstideski. Teisest küljest sõnad on üldiselt haruldased ning esinevad selles tekstis ainult paar korda, võivad nad juba hästi eristada seda teksti teistest. Tulemus sõltub täpsest valemist, mida on hetkel rakendatud. Tidytext paketis on selle hõlpsaks leidmiseks olemas oma käsk bind_tf_idf(). See käsk liidab andmestikule tf-idf märksõnalisuse määrad. bind_tf_idf() võtab sisendiks sõna, grupeeriva tulba ning sõna sageduse igas grupis ning võrdleb seda sõna esinemisega teistes gruppides. Käsk teeb arvutustöö kõikide sõnade kohta ning liidab tulemused andmestikuga. Mida suurem on tf-idf, seda märgilisem on see sõna selle grupi jaoks. Niisiis, saame käsu abiga hõlpsasti tuvastada teatud gruppi eristavad sõnad. Näiteks arvutame alustuseks artiste eristavad sõnad. Arvutame artiste teistest eristavad sõnad. Kuna me oleme seni kasutanud peatükis ainult fraase, siis arvutame kõigepealt laulusõnad. laulusonad &lt;- edetabel %&gt;% unnest_tokens(word,lyrics) Leidmaks tf-idf märksõnu, loendame sõnu artistide kaupa ning siis juhendame, bind_tf_idf() funktsiooni, et ta kasutaks seda informatsiooni oma mõõdikute välja arvutamiseks. Lõpuks järjestame sõnad tf_idf alusel, kus suurem väärtus näitam suuremat eristusjõudu. tf_idf &lt;- laulusonad %&gt;% group_by(artist) %&gt;% count(word) %&gt;% bind_tf_idf(word, artist,n) %&gt;% arrange(desc(tf_idf)) Vaatame tabelit esialgu ise lähemalt. View(tf_idf) Tabelis näeme, et eristavad sõnad on väga tihti needsamad, mis olid väga sagedased teatud artistidele. See on parasjagu nii, kuna need olid ühtlasi sõnad, mida teised artistid kasutasid väga vähe. Näiteks satelliidid, Maiu ja piimaauto on üldiselt lauludes harva kasutatavad sõnad. Põnevamaks muutub see määr kui püüda vaadata mõne konkreetse artisti eristavaid märksõnu.Smilersi puhul on levinud sõnad ja, ma, ei ikkagi tipus, kuna neid kasutatakse nende lugudes läbivalt väga palju. Haruldasemad sõnad ilmnevad hiljem, aga on siiski kohal teises kümendis laulusonad %&gt;% group_by(artist) %&gt;% count(word) %&gt;% bind_tf_idf(word, artist,n) %&gt;% arrange(desc(tf_idf)) %&gt;% filter(artist==&quot;Smilers&quot;) %&gt;% filter(row_number()&lt;21) ## # A tibble: 20 x 6 ## # Groups: artist [1] ## artist word n tf idf tf_idf ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Smilers ja 290 0.0426 0.544 0.0232 ## 2 Smilers ma 196 0.0288 0.676 0.0195 ## 3 Smilers ei 179 0.0263 0.605 0.0159 ## 4 Smilers oooo 24 0.00352 4.24 0.0150 ## 5 Smilers on 234 0.0344 0.363 0.0125 ## 6 Smilers sa 94 0.0138 0.862 0.0119 ## 7 Smilers et 95 0.0140 0.783 0.0109 ## 8 Smilers shalala 12 0.00176 5.85 0.0103 ## 9 Smilers kao 15 0.00220 4.24 0.00935 ## 10 Smilers kui 99 0.0145 0.643 0.00934 ## 11 Smilers segamini 12 0.00176 5.16 0.00909 ## 12 Smilers kummagi 10 0.00147 5.85 0.00859 ## 13 Smilers mingil 10 0.00147 5.85 0.00859 ## 14 Smilers mojito 10 0.00147 5.85 0.00859 ## 15 Smilers mind 63 0.00925 0.918 0.00849 ## 16 Smilers ainult 31 0.00455 1.86 0.00848 ## 17 Smilers mida 39 0.00573 1.47 0.00842 ## 18 Smilers kuhugi 16 0.00235 3.55 0.00834 ## 19 Smilers põleda 11 0.00162 5.16 0.00833 ## 20 Smilers seisan 19 0.00279 2.96 0.00826 Artistil, millel on lugusid korpuses vähem, on ka rohkem esil mõne üksiku loo märksõnad. Näiteks Nublul on korpuses kaks lugu ning sõnad, mis kordusid neis lugudes tihti, on selgelt esil. Nt ou, mina, ka. laulusonad %&gt;% group_by(artist) %&gt;% count(word) %&gt;% bind_tf_idf(word, artist,n) %&gt;% arrange(desc(tf_idf)) %&gt;% filter(artist==&quot;Nublu&quot;) ## # A tibble: 312 x 6 ## # Groups: artist [1] ## artist word n tf idf tf_idf ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Nublu ou 22 0.0280 4.47 0.125 ## 2 Nublu mina 29 0.0369 2.14 0.0790 ## 3 Nublu ka 39 0.0497 1.34 0.0666 ## 4 Nublu pa 10 0.0127 4.47 0.0569 ## 5 Nublu parap 6 0.00764 5.85 0.0447 ## 6 Nublu peale 12 0.0153 2.21 0.0339 ## 7 Nublu nagu 18 0.0229 1.46 0.0334 ## 8 Nublu bonnie 4 0.00510 5.85 0.0298 ## 9 Nublu cappuccino 4 0.00510 5.85 0.0298 ## 10 Nublu clyde 4 0.00510 5.85 0.0298 ## # … with 302 more rows Mõnikord ei kasutatudki palju erinevaid sõnu. Näiteks artistil Koer saab need sõnad peaaegu kahe käe sõrmedel kokku lugeda ja ainult seetõttu, et ühe sõna iga täht on ka eraldi välja öeldud. Siiski on näha, et ‘on’ on neil kõige vähem eristavam sõna. laulusonad %&gt;% group_by(artist) %&gt;% count(word) %&gt;% bind_tf_idf(word, artist,n) %&gt;% arrange(desc(tf_idf)) %&gt;% filter(artist==&quot;Koer&quot;) ## # A tibble: 11 x 6 ## # Groups: artist [1] ## artist word n tf idf tf_idf ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Koer maiu 16 0.205 5.85 1.20 ## 2 Koer piimaauto 16 0.205 5.85 1.20 ## 3 Koer u 4 0.0513 3.45 0.177 ## 4 Koer m 4 0.0513 3.29 0.169 ## 5 Koer o 4 0.0513 3.29 0.169 ## 6 Koer i 6 0.0769 1.55 0.119 ## 7 Koer a 6 0.0769 1.52 0.117 ## 8 Koer p 2 0.0256 4.47 0.115 ## 9 Koer n 2 0.0256 3.91 0.100 ## 10 Koer t 2 0.0256 2.96 0.0759 ## 11 Koer on 16 0.205 0.363 0.0745 Keskmise laulude hulgaga artistidel tulevad samuti märksõnad üksikutest lauludest esile. Nt Kuldsel Triol hopp, johanna, vodka, laika jne on kõik sõnad, mis on korpuses üldiselt väga haruldased, aga nende lugude seas piisavalt sagedased. See, millised sõnad selle valemiga esile tulevad sõltub niisiis nii korpuse iseloomust kui ka tekstide enda suurusest ja kujust. Selleks, et nendest seostest paremini aru saada, tasub katsetada erinevate tekstide puhul, et mis märksõnad peale jäävad. Mõnikord võib lisada neile lisafiltreid - näiteks jätta üldse kõrvale sõnad, mis on väga haruldased või väga tihti kasutatud. laulusonad %&gt;% group_by(artist) %&gt;% count(word) %&gt;% bind_tf_idf(word, artist,n) %&gt;% arrange(desc(tf_idf)) %&gt;% filter(artist==&quot;Kuldne Trio&quot;) ## # A tibble: 266 x 6 ## # Groups: artist [1] ## artist word n tf idf tf_idf ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Kuldne Trio hopp 30 0.0459 5.85 0.269 ## 2 Kuldne Trio johanna 30 0.0459 5.85 0.269 ## 3 Kuldne Trio vodka 30 0.0459 5.85 0.269 ## 4 Kuldne Trio laika 16 0.0245 5.16 0.126 ## 5 Kuldne Trio russkaja 14 0.0214 5.85 0.125 ## 6 Kuldne Trio tantsi 15 0.0230 4.06 0.0933 ## 7 Kuldne Trio rossija 8 0.0123 5.85 0.0717 ## 8 Kuldne Trio kotka 4 0.00613 5.85 0.0358 ## 9 Kuldne Trio varblasest 4 0.00613 5.85 0.0358 ## 10 Kuldne Trio kuni 10 0.0153 2.33 0.0356 ## # … with 256 more rows Proovi ise! Vali välja üks artist ning leia selle artisti kõige eristavamad sõnad. #--------------------------------------------- #--------------------------------------------- Proovi ise! Vali välja ka üks laul ning proovi leida eristavad sõnad selle laulu kohta. #--------------------------------------------- #--------------------------------------------- 6.6 Sõnastik unnest_tokens() - segmenteeri tekst ühikute kaupa unnest_tokens(word, lyrics, token = “ngrams”, n = 1, n_min = 1) - segmenteeri tekst sõnedeks unnest_tokens(bigram, lyrics, token = “ngrams”, n = 2, n_min = 2) - segmenteeri tekst bigrammideks unnest_tokens(trigram, lyrics, token = “ngrams”, n = 3, n_min = 3) - segmenteeri tekst trigrammideks str_detect(muutuja, “sõne”) - kontrolli, kas tekstis on selline järjend. võib kasutada regulaaravaldisi str_extract(muutuja, “sõne”) - võta välja tekstist sellele järjendile vastavad osad. võib kasutada regulaaravaldisi bind_tf_idf() - liidab andmestikule tf-idf märksõnalisuse määrad 6.7 Harjutusülesanded Leia populaarseimad bigrammid 1990ndatel aastatel. Leia kõik trigrammid, mis algavad sõnaga “ma” Leia kõige rohkem ühe loo sees korduvad trigrammid. Millised märksõnad eristavad aastat 2000 teistest aastatest? Millised märksõnad eristavad eristavad Smilersi edukaimat laulu teistest Smilersi lauludest? "],
["graafikute-loomine-r-is.html", "Peatükk 7 Graafikute loomine R-is 7.1 Graafiku ülesehitus 7.2 Joonisekihtide liigid 7.3 Tabeli viimistlemine 7.4 Sõnastik 7.5 Harjutusülesanded", " Peatükk 7 Graafikute loomine R-is Siiani tegelesime puhtalt andmete töötlemisega. Ühe võimalusena kasutatakse neid edasiseks analüüsiks või ülevaadete koostamiseks. Teise võimalusena aga on võimalik tabelis leitud iva paigutada graafikule juba ülevaatlikult nähtavaks. Hea pilt on mõnikord väärt tuhat sõna, nagu öeldakse. 7.1 Graafiku ülesehitus Tidyverse raamistikus ja R-is üldiselt on selle jaoks pakett ggplot2. Sellel on omakorda ka hulk laiendusi, mis avavad võimalike graafikute ringi. Tidyverse pakett loeb selle automaatselt sisse. Näidisena võime uuesti vaadata loengus nähtud gapminder graafikut. Vaata selle seletust siin: https://www.gapminder.org/answers/how-does-income-relate-to-life-expectancy/. Seal on kujutatud, kuidas inimeste keskmine eluiga sõltub riigi sissetulekust. gapminder &lt;- read.csv(&quot;data/gapminder.csv&quot;) gapminder %&gt;% group_by(country) %&gt;% filter(year==max(year)) %&gt;% ggplot(aes(x=gdpPercap,y=lifeExp,size=pop,color=continent))+ geom_point()+ scale_x_log10() Graafik ise on tehtud minimaalse andmetöötlusega (lihtsalt on vaja valida välja aasta) ja lihtsa struktuuriga. Seal määratakse ära, et x-teljel on rikkus, y-teljel on eluiga, punkti suurus sõltub rahvaarvust ja värv maailmajaost. Määratud on, et tegemist on punktgraafikuga ja x-telg on viidud logaritmskaalale. Vaatame lähemalt, kuidas see graafik ehitatud on. Üldine põhimõte on ggplot2-es sama kui tidyverse-is üldisel. Et alustades mingist objektist lisatakse sellele aina töötlust. Ainult et joonise puhul ei muudeta pöördumatult loodud objekti, vaid lisatakse sellele uusi kihte, mis selle siis ümber kujundavad. ggplot() jooniste puhul on kihid ühendatud + märkidega, mitte %&gt;% märgiga nagu ülejäänud tidyverse’is. Ühe graafiku põhistruktuur on järgmine: data %&gt;% ggplot(aes(x=var1, y=var2)) + geom_point() Võime selle struktuuri lahti seletada esimese näite põhjal. Alustuseks on meil siis andmestik. Teeme kohe vajalikud tööd sellega ära ja salvestame muutujasse ‘andmed’. Siis saame edasi otse sellele viidata. andmed &lt;- gapminder %&gt;% group_by(country) %&gt;% filter(year==max(year)) Vaatame korraks ka sellesse tabelisse sisse. Seal on iga riigi kohta üks rida. Real on märgitud riigi nimi, maailmajagu, oodatav eluiga, rahvaarv ja rikkuse näiduna rahvuslik kogutoodang ehk gdp inimese kohta. andmed ## # A tibble: 142 x 6 ## # Groups: country [142] ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 2007 43.8 31889923 975. ## 2 Albania Europe 2007 76.4 3600523 5937. ## 3 Algeria Africa 2007 72.3 33333216 6223. ## 4 Angola Africa 2007 42.7 12420476 4797. ## 5 Argentina Americas 2007 75.3 40301927 12779. ## 6 Australia Oceania 2007 81.2 20434176 34435. ## 7 Austria Europe 2007 79.8 8199783 36126. ## 8 Bahrain Asia 2007 75.6 708573 29796. ## 9 Bangladesh Asia 2007 64.1 150448339 1391. ## 10 Belgium Europe 2007 79.4 10392226 33693. ## # … with 132 more rows Nüüd sellest graafiku tegemiseks, saadame ta %&gt;% toruga ggplot() funktsiooni. Alustuseks on graafik täiesti tühi. andmed %&gt;% ggplot() ggplot() funktsiooni sisse saab määrata erinevaid parameetrid. Kõige tähtsamad parameetrid - see, mida kuvatakse lähevad omakorda aes() funktsiooni sisse. aes() ehk aesthetics (esteetika). Selle süntaks on üsna otsene, parameetrite nimed on selle järgi, kuhu info lõpuks saadetakse ja parameetri sisu on see tabeli tunnus, mis sinna peaks minema. Kui me määrame x-teljele gdp, seab ka graafik paika x-telje, mis mahutaks ära gdp. ggplot() saab aru, et tegemist on numberväärtusega ning paneb paika selle suurima ja väikseima väärtuse. andmed %&gt;% ggplot(aes(x=gdpPercap)) Määrates aes() funktsioonis y-telje, saab ggplot() samamoodi aru sellest, kuidas ehitada üles y-telg. Samade parameetrite alusel andmed %&gt;% ggplot(aes(y=lifeExp)) Siis kui me määrame ära nad mõlemad korraga, saame ette koordinaatteljestiku, mida graafikul nägime. andmed %&gt;% ggplot(aes(x=gdpPercap,y=lifeExp)) Koordinaatteljele saame siis hakata asetama andmeid mitmel eri moel. Üks lihtsamaid viise on punktgraafik ehk hajuvusdiagramm. Iga rida ehk andmepunkt on siis kujutatud ühe punktina. Selle jaoks on lisame uue kihina geom_point(). Märka, et rea lõppu lisasime ka + märgi. Tulemus on näha all. andmed %&gt;% ggplot(aes(x=gdpPercap,y=lifeExp))+ geom_point() Meie graafik ülal oli veidike teistsugune seetõttu, et seal oli muudetud x-telje skaalat. Seda sellepärast, et tüüpiliselt rikkad riigid on väga väga rikkad, vaeste riikide vaheline kaugus on palju väiksem. Logaritm-muundamine vähendab andmestikus suurte väärtuste distantsi ja kasvatab väikeste väärtuste oma. Meie andmete puhul jaotab ta nad skaalale ühtlasemalt ära. Kujutamaks meie andmepunkte logarigm-skaalal lisame joonisele kihi scale_x_log10(), mis ütleb et kujutagu x-teljel väärtusi logaritmskaalal. Telgede muundamiseks on veel palju võimalusi. Nende avastamiseks vaadake ggplot2 paketi võimalusi. andmed %&gt;% ggplot(aes(x=gdpPercap,y=lifeExp))+ geom_point()+ scale_x_log10() Nüüd on graafik juba sama kujuga kui oli alguses. Puudu on veel punktide värvid ja suurused. Samamoodi nagu x-telg ja y-telg, läheb see info aes() funktsiooni sisse. Määrame ära, et suuruseks on rahvaarv, ehk size = pop. Rahvaarv on numbriline väärtus ja ggplot2 leiab punkti suurusele ise skaala, mis sobib nende väärtustega. andmed %&gt;% ggplot(aes(x=gdpPercap,y=lifeExp, size=pop))+ geom_point()+ scale_x_log10() Ja määrame lisaks ka, et punkti värv peaks tulenema maailmajaost. Kuna maailmajagu on faktormuutuja, kus R näeb ära, et seal on viis eri väärtust, leiab ta viis värvi, mida seal kasutada. Ja kokkuvõttes saamegi sama graafiku, mis oli alguses. andmed %&gt;% ggplot(aes(x=gdpPercap,y=lifeExp, size=pop, color=continent))+ geom_point()+ scale_x_log10() 7.2 Joonisekihtide liigid Täpselt samamoodi kui rahvastikuandmetega ülal saame käituda ka tekstidest tehtud tabelitega. Lihtsalt me peame valmistama andmetabeli. Määratlema ära, mis on x-teljel, mis on y-teljel, mis määrab ära värvi jne ning mis kihte me graafikule selle põhjal lisame. Peamised kihid, millega tasuks tuttav olla on: ggplot() - aluskiht geom_point() - punktgraafik, kus iga andmepunkt on punkt geom_line() - joongraafik, kus need punktid on mingil alusel ühendatud joontega geom_col() - tulpdiagramm, kus tulba suurus näitab väärtuse suurust geom_text() - lisab teksti graafikule. teksti asukohad on samuti x ja y telje järgi geom_tile() - ruudustikgraafik, kus x ja y telg määravad millise ruuduga on tegemist Näiteks võime alustuseks teha graafiku parimatest artistidest ja kuvada mitu lugu neil edetabelites oli. Meil on selleks vaja jälle algandmeid. edetabel &lt;- read_tsv(&quot;data/eesti_top40/eesti_skyplus_top40_1994-2018.tsv&quot;) ## Parsed with column specification: ## cols( ## year = col_double(), ## rank = col_double(), ## votes = col_double(), ## artist = col_character(), ## song = col_character(), ## filename = col_character(), ## source = col_double(), ## lyrics = col_character(), ## language = col_character() ## ) Loendame edetabelis artistide esinemiskordi ning võtame neist välja esikümne. Alustame tühjast graafikust. edetabel %&gt;% count(artist,sort=T) %&gt;% filter(row_number()&lt;11) %&gt;% ggplot() Märgime ära graafiku skaala. X-teljele artisti nime ja y-teljele lugude arvu. Nüüd teeb ggplot() veidi teistsuguse graafiku kui eelmine, kuna artisti nimi ei ole number ning sellele ei ole võimalik teha sujuvat skaalat. Selle asemel kirjutab ggplot kõik nimed graafiku allserva. edetabel %&gt;% count(artist,sort=T) %&gt;% filter(row_number()&lt;11) %&gt;% ggplot(aes(x=artist,y=n)) Lisame nüüd punktikihi, kus iga punkt paikneb oma artisti kohal ning tähistab seda, kui palju lugusid tal oli. edetabel %&gt;% count(artist,sort=T) %&gt;% filter(row_number()&lt;11) %&gt;% ggplot(aes(x=artist,y=n))+ geom_point() Ja punktid jõudsidki graafikule. Antud juhul võiks ehk tulpdiagramm sobida paremini kui punktid. Asendame selle jaoks geom_point() funktsiooni geom_col() funktsiooniga. X-telg ja y-telg võivad jääda samaks. Tulbad annavad mastaabist parema ülevaate. edetabel %&gt;% count(artist,sort=T) %&gt;% filter(row_number()&lt;11) %&gt;% ggplot(aes(x=artist,y=n))+ geom_col() Ja ongi muudetud. Märgata võib, et hetkel on nimed tabelis tähestiku järjekorras, mis ehk ei anna kõige paremat ettekujutust sellest, mis järjekorras see top10 ikkagi on. See on nii sellepärast, et tegemist on faktor-muutujaga, mille jaoks me ei ole andnud ggplot()-ile eraldi juhiseid. Faktor-muutujad on tihti vaikimisi tähestiku järjekorras. Tasemete muutmiseks on mitmeid viise (vaata sissejuhatavat osa). Tidyverse’is on pakutud faktorite töötluseks omaette pakett forcats ehk for categorical variables (kategooriliste tunnuste jaoks). Tasemete järjestuse muutmiseks on seal eraldi käsk fct_reorder(), kus tuleb lihtsalt näidata, mis tulpa järjestada ja siis anda järjestamise alus. Antud juhul püüame siis järjestada artisti tulba tasemeid n tulba väärtuste alusel, kahanevas järjekorras. Selle jaoks võime kirjutada fct_reorder(artist, -n). Miinusmärk n ees muudab pöörab ümber numbrite skaala kuna miinusmärgiga on suuremad numbrid väiksema väärtusega ehk -100 on väiksem kui -1. edetabel %&gt;% count(artist,sort=T) %&gt;% filter(row_number()&lt;11) %&gt;% mutate(artist=fct_reorder(artist,-n)) %&gt;% ggplot(aes(x=artist,y=n))+ geom_col() Ilusama graafiku jaoks on võimalik jälle telgi sättida veidi, seekord võime ära vahetada x-telje ja y-telje. Selle jaoks on käsk coord_flip(). Sellisel juhul ehk sobib ka paremini järjestada artistid miinusmärgita n alusel. edetabel %&gt;% count(artist,sort=T) %&gt;% filter(row_number()&lt;11) %&gt;% mutate(artist=fct_reorder(artist,n)) %&gt;% ggplot(aes(x=artist,y=n))+ geom_col()+ coord_flip() Me võime teha kõiki endale tuttavaid operatsioone oma andmetega. Me võime näiteks hea sarnase tulpdiagrammi Smilersi lugude nimedega. Paneme lugude arvu asemel y-teljele nende koha edetabelis. X-teljele läheb artisti asemele siis loo nimi. Teeme taaskord vahetatud telgedega tulpdiagrammi geom_col(). edetabel %&gt;% filter(artist==&quot;Smilers&quot;) %&gt;% ggplot(aes(x=song,y=rank))+ geom_col()+ coord_flip() Ja joondame nad fct_reorder() abil edetabelipositsiooni järgi. edetabel %&gt;% filter(artist==&quot;Smilers&quot;) %&gt;% mutate(song=fct_reorder(song,rank)) %&gt;% ggplot(aes(x=song,y=rank))+ geom_col()+ coord_flip() Nüüd näeme tabelist, et kuna mõni lugu esines kaks korda, siis pole tulpdiagramm ehk selle jaoks parim. Muudame geom_col() geom_point()-iks, et teha tulpdiagrammist punktdiagramm. edetabel %&gt;% filter(artist==&quot;Smilers&quot;) %&gt;% mutate(song=fct_reorder(song,rank)) %&gt;% ggplot(aes(x=song,y=rank))+ geom_point()+ coord_flip() Tähele võib panna, et fct_reorder() võttis lugude järjestamisel aluseks punktide keskmise. See on antud vaikeväärtusena nii selles funktsioonis. Et meie võimalusi lähemalt uurida, võime kasutada ?fct_reorder, et näha selle võimalusi. ?fct_reorder Selle põhjal näeme, et lisaks hädavajalikele parameetritele võib lisada ka sellele funktsioonile kolmanda parameetri, mis on vaikimisi mean ehk keskmise võtmine. Me võime selle asemele panna min ehk miinimumi võtmine ja siis me saame need lood järjestatud just parima koha alusel. Nüüd on järjekord veidi teistsugune ja mitu aastat tabelis olnud lood ei saa selle eest enam miinuspunkte. edetabel %&gt;% filter(artist==&quot;Smilers&quot;) %&gt;% mutate(song=fct_reorder(song,rank,min)) %&gt;% ggplot(aes(x=song,y=rank))+ geom_point()+ coord_flip() Sarnaseid graafikuid võime teha ükskõik millest. Näiteks võime teha sama oma sagedussõnastikuga. Kõigepealt teeme laulude tekstid sõnadeks ja salvestame selle muutuja, kuna me kasutame seda korduvalt. laulusonad &lt;- edetabel %&gt;% unnest_tokens(word,lyrics) Seejärel loendame sõnu, võtame neist top10, muudame sõnade tasemete järjekorda ja kuvame nad samasuguse tulpdiagrammiga. Saamegi ülevaate sellest kui palju oli kõige levinumaid sõnu terve tekstikorpuse peale. laulusonad %&gt;% count(word,sort=T)%&gt;% filter(row_number()&lt;11) %&gt;% mutate(word=fct_reorder(word,n)) %&gt;% ggplot(aes(x=word,y=n))+ geom_col()+ coord_flip() Me võime kuvada ka mõne muu osa nendest sõnadest, näiteks siis sõnad mis olid 120.-130. kohal populaarsuselt. Nagu mujalgi, saame andmeid viia varem sellisele kujule nagu me soovime. laulusonad %&gt;% count(word,sort=T)%&gt;% filter(row_number()&gt;120&amp;row_number()&lt;131) %&gt;% mutate(word=fct_reorder(word,n)) %&gt;% ggplot(aes(x=word,y=n))+ geom_col()+ coord_flip() Võime ka kasutada sample_n() funktsiooni võtta 10 juhuslikku sõna. Iga kord kui me seda koodi jooksutame, saame sedasi uue tabeli. laulusonad %&gt;% count(word,sort=T)%&gt;% sample_n(10)%&gt;% mutate(word=fct_reorder(word,n)) %&gt;% ggplot(aes(x=word,y=n))+ geom_col()+ coord_flip() Me võime samal viisil kuvada ka kõik sõnad. Kuna sõnu on kokku väga palju, siis tasub ehk neid kuvada mitte nimeliselt vaid mõne muu tunnuse alusel. Võtame selleks näiteks populaarsuse järjekorranumbri lihtsalt. Jooniselt on näha, keeleteaduses tuntud zipf-i seadust, et ainult üksikuid sõnu on tekstides väga palju, aga suurem osa sõnu on üpris haruldased. laulusonad %&gt;% count(word,sort=T)%&gt;% mutate(rownr=row_number()) %&gt;% ggplot(aes(x=rownr,y=n))+ geom_point() Saame ehk veidi parema pildi kasutades jälle logaritm-skaalat. laulusonad %&gt;% count(word,sort=T)%&gt;% mutate(rownr=row_number()) %&gt;% ggplot(aes(x=rownr,y=n))+ geom_point()+ scale_y_log10() Et joonisest veel paremini aru saada, võime lisada ka nimed mõnele punktidest. Selleks salvestame ajutiselt meie tabeli, kuna meil on vaja seda hiljem muundada ja võtta sealt kümme juhuslikku rida. plotdata &lt;- laulusonad %&gt;% count(word,sort=T)%&gt;% mutate(rownr=row_number()) Kui me asetame aes() funktsiooni hetkel ggplot() sisse, mis juhib tervet graafikut, siis me võime nii andmestikku kui parameetreid sättida ka igal kihil eraldi. Näiteks hetkel, nimede saamiseks võime geom_text() sisse panna uued andmed, mis on ainult alamhulk tervest andmestikust, mis on saadud sample_n() funktsiooni kaudu. geom_text kasutab label parameetrit teksti leidmiseks. plotdata %&gt;% ggplot(aes(x=rownr,y=n,label=word))+ geom_point()+ geom_text(data=plotdata %&gt;% sample_n(10),vjust=-1)+ scale_y_log10() Spetsiifilisemaid edetabeleid võib teha mitmeti. Näiteks võtame kõik Põhja-Tallinna lood ja kuvada nende saadud edetabelikohad läbi aastate. edetabel %&gt;% filter(artist==&quot;Põhja-Tallinn&quot;) %&gt;% ggplot(aes(x=year,y=rank))+ geom_point() Võime neile kõigile lisada ka nimed, kasutades selleks geom_text() funktsiooni ja label parameetrit. edetabel %&gt;% filter(artist==&quot;Põhja-Tallinn&quot;) %&gt;% ggplot(aes(x=year,y=rank, label=song))+ geom_point()+ geom_text(vjust=-1) Lisaks võime lisada neile ka joone. Ütleme, et graafik grupeeriks laule nende nimede alusel. Nii saavad sama loo eri aastakäigud ühendatud kokku. edetabel %&gt;% filter(artist==&quot;Põhja-Tallinn&quot;) %&gt;% ggplot(aes(x=year,y=rank, label=song,group=song))+ geom_point()+ geom_line()+ geom_text(vjust=-1) Lisaks võime värvida nad kõik ka aastakäigu järgi. Selleks et aastakäiku lugeda kategoorilise muutujana, paneme selle ümber funktsiooni factor(). edetabel %&gt;% filter(artist==&quot;Põhja-Tallinn&quot;) %&gt;% ggplot(aes(x=year,y=rank, label=song,group=song,color=factor(year)))+ geom_point()+ geom_line()+ geom_text(vjust=-1) Viimaks võime anda tabelile ka pealkirja labs() funktsiooni kaudu. Sarnaselt nagu aes() funktsiooniski, tuleb lihtsalt anda parameetrite nimed selle järgi, kuhu info saata. title määrab pealkirja, x määrab x-telje väärtuse, y määrab y-telje väärtuse. edetabel %&gt;% filter(artist==&quot;Põhja-Tallinn&quot;) %&gt;% ggplot(aes(x=year,y=rank, label=song,group=song,color=factor(year)))+ geom_point()+ geom_line()+ geom_text(vjust=-1)+ labs(title=&quot;Pealkiri läheb siia&quot;,x=&quot;x-telg&quot;,y=&quot;y-telg&quot;) Kui me oleme loendanud erinevat tüüpi andmeid, võiksime selle näitamiseks kasutada samuti värvi. Näiteks meie andmestikus leiame lugusid mitmes eri keeles ning me võime neid loendada. edetabel %&gt;% count(language) ## # A tibble: 6 x 2 ## language n ## &lt;chr&gt; &lt;int&gt; ## 1 en 133 ## 2 es 1 ## 3 et 686 ## 4 fr 1 ## 5 it 1 ## 6 &lt;NA&gt; 178 Seejuures võime me neid loendada ka aastate kaupa. edetabel %&gt;% count(language,year) ## # A tibble: 76 x 3 ## language year n ## &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 en 1994 2 ## 2 en 1995 2 ## 3 en 1997 4 ## 4 en 1998 3 ## 5 en 1999 10 ## 6 en 2000 10 ## 7 en 2001 3 ## 8 en 2002 8 ## 9 en 2003 8 ## 10 en 2004 9 ## # … with 66 more rows Ja sellest andmestikust saamegi teha juba tulpdiagrammi. Selle jaoks, et anda tulpadele värvi, saame kasutada parameetrit fill, mis määrab värvitava ala täite. Asetame selleks keele parameetri. edetabel %&gt;% count(language,year) %&gt;% ggplot(aes(x=year,y=n,fill=language))+ geom_col() Joonisel on siis näha, mis keeles said lood eesti edetabelisse ja on ehk huvitav näha, et viimase 25 aasta jooksul on peaaegu alati olnud mõned lood inglise keeles, aga need on alati olnud üsna väike hulk tervest kogusest. Samas tuleb ka märgata, et paljudel lugudel on sõnad puudu ja seetõttu ka keel määramata. Me võime teha tulpdiagramme ka üksikute sõnade kohta. Võime näiteks võta Kuldse Trio kõige sagedamini kasutatud sõnad. laulusonad %&gt;% group_by(artist) %&gt;% count(word,sort=T) %&gt;% filter(artist==&quot;Kuldne Trio&quot;) %&gt;% mutate(word=fct_reorder(word,n)) %&gt;% filter(row_number()&lt;11) %&gt;% ggplot(aes(x=word,y=n,fill=word))+ geom_col()+ coord_flip() Ja sama võime teha ka märksõnade kohta, järjestades nad selle alusel kui eristavad nad Kuldsele Triole on. laulusonad %&gt;% group_by(artist) %&gt;% count(word) %&gt;% bind_tf_idf(word, artist,n) %&gt;% arrange(desc(tf_idf)) %&gt;% filter(artist==&quot;Kuldne Trio&quot;) %&gt;% mutate(word=fct_reorder(word,tf_idf)) %&gt;% filter(row_number()&lt;11) %&gt;% ggplot(aes(x=word,y=tf_idf,fill=word))+ geom_col()+ coord_flip() Me võime ka uuesti vaadata sõnu laulude sees. Selleks taaselustame sõnade asukohad ja kordused ning salvestame nad muutujatena. asukohad &lt;- laulusonad %&gt;% group_by(artist,song,year) %&gt;% mutate(nr=row_number(), n=n()) %&gt;% mutate(asukoht=nr/(n+1)) %&gt;% mutate(asukoht_perc=floor(asukoht*10)/10)%&gt;% ungroup() kordused &lt;- laulusonad %&gt;% filter(language==&quot;et&quot;) %&gt;% group_by(artist, song,year) %&gt;% count(word,sort=T) %&gt;% filter(!word %in% c(&quot;ref&quot;)) %&gt;% mutate(proportsioon=n/sum(n)) %&gt;% arrange(desc(proportsioon)) %&gt;% ungroup() asukohad_ja_kordused &lt;- kordused %&gt;% filter(row_number()&lt;21) %&gt;% inner_join(asukohad,by=c(&quot;artist&quot;,&quot;song&quot;,&quot;year&quot;,&quot;word&quot;)) kus_on_kordused &lt;- asukohad_ja_kordused %&gt;% group_by(artist,song,year,word) %&gt;% count(asukoht_perc) Me võime lihtsalt võtta siis 20 kõige enamate kordustega sõna ühes loos ning kuvada nende asukohad x teljele. Y-teljele võiks panna sõna, aga et oleks selge, et on ikka see sõna selles loos, asetame sinna sõna ja laulu kombinatsiooni. Selleks on ggplot2-s interaction() funktsioon, mis võib graafikule panna kategooriliste muutujate kombinatsioone. asukohad_ja_kordused %&gt;% ggplot(aes(x=asukoht,y=interaction(song,word)))+ geom_point() Viimaks võime trükkida ka varasemas peatükis trükitud tabeli graafiliselt, kus iga laul on jaotatud kümnendikeks ja igas kümnendikus on võetud selle sõna esinemise suhteline sagedus. Selleks sobib geom_tile() funktsioon, mis asetab väärtused graafikul ruudustikule. kus_on_kordused %&gt;% group_by(artist,song,word,year) %&gt;% mutate(prop=n/sum(n)) %&gt;% ggplot(aes(x=asukoht_perc,y=interaction(song,word),fill=prop))+ geom_tile() 7.3 Tabeli viimistlemine See mida me võime kuvada sõltub puhtalt sellest, kuidas me andmeid töötleme ja esitame. Lõpuks maksab ka see kuidas me seda viimistleme. Me võime nende andmetega moodustada ka ajalise ülevaate parimatest eesti popartistidest - et kui kaua nad on tipus olnud. Võime selleks võtta meie artistide edetabeli top10. top10 &lt;- edetabel %&gt;% count(artist,sort=T) %&gt;% filter(row_number()&lt;11) Kõrvale saame teha teise tabeli, mis võtab välja esimese ja viimase aasta kui artist edetabelisse jõudis. artist_career &lt;- edetabel %&gt;% group_by(artist) %&gt;% summarise(first=min(year),last=max(year)) Me saame nad kokku panna inner_join() funktsioniga ja saamegi tabeli, mida kuvada. top10 %&gt;% inner_join(artist_career,by=&quot;artist&quot;) %&gt;% mutate(artist=fct_reorder(artist,n)) ## # A tibble: 10 x 4 ## artist n first last ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Smilers 47 1996 2016 ## 2 Terminaator 46 1994 2017 ## 3 2 Quick Start 24 1994 2011 ## 4 Ines 21 1999 2014 ## 5 Tanel Padar &amp; The Sun 16 2005 2015 ## 6 Ott Lepland 15 2009 2017 ## 7 Caater 14 1997 2002 ## 8 Põhja-Tallinn 14 2012 2017 ## 9 Jam 12 1994 2004 ## 10 Laura 12 2005 2018 Kuvamiseks võiksime teha joondiagrammi iga artisti kestusajast. Võime nüüd kasutada lisatrikki, millega saab aes() funktsiooni panna iga kihi sisse eraldi. See kehtib siis oma kihi piires. Märgime siis esimese edetabeliloo aja ühe punktina ja teise edetabeliloo aja teise punktina. top10 %&gt;% inner_join(artist_career,by=&quot;artist&quot;) %&gt;% mutate(artist=fct_reorder(artist,n)) %&gt;% ggplot()+ geom_point(aes(x=artist,y=first))+ geom_point(aes(x=artist,y=last)) Vahetame ära x ja y telje. top10 %&gt;% inner_join(artist_career,by=&quot;artist&quot;) %&gt;% mutate(artist=fct_reorder(artist,n)) %&gt;% ggplot()+ geom_point(aes(x=artist,y=first))+ geom_point(aes(x=artist,y=last))+ coord_flip() Seejärel võime lisada ka joone geom_segment(), mis algab esimesest aastast ja lõppeb viimase aastaga ning püsib kogu ulatuses artisti joonel. Näeme, et Smilers ja Terminaator on meid saatnud peaaegu kogu tabelite kestvuse aja. Caater oli küll äärmiselt populaarne, aga seda üsna lühikest aega. Ott Lepland ja Põhja-Tallinn on aga ilmselt alles tõusuteel. top10 %&gt;% inner_join(artist_career,by=&quot;artist&quot;) %&gt;% mutate(artist=fct_reorder(artist,n)) %&gt;% ggplot()+ geom_point(aes(x=artist,y=first))+ geom_point(aes(x=artist,y=last))+ geom_segment(aes(x=artist,xend=artist,y=first,yend=last))+ coord_flip() Graafiku väljanägemise parandamiseks võime talle lisada ka visuaalse teema theme_bw() ehk mustvalge teema. Ja tegelikult olles lisanud geom_segment funktsiooni, ei ole need punktid joonte otstes enam vajalikud. top10 %&gt;% inner_join(artist_career,by=&quot;artist&quot;) %&gt;% mutate(artist=fct_reorder(artist,n)) %&gt;% ggplot()+ geom_segment(aes(x=artist,xend=artist,y=first,yend=last),size=3)+ coord_flip()+ theme_bw()+ labs(title=&quot;Eesti artistide karjäärid SkyPlus Top 40-s 1994-2019&quot;,x=&quot;&quot;,y=&quot;&quot;) Viimaks võime me salvestada selle graafiku ka eraldi failina. ggplot2-s on selle jaoks funktsioon ggsave(), mis vaikimisi võtab viimase trükitud graafiku ja salvestab selle meie nimetatud kohta. Graafiku tüübi võtab ta faili nime järgi. Salvestame selle näiteks .png failina. ggsave() määrab sellele ise suuruse - see ei pruugi minna alati täppi. ggsave(&quot;figures/top10_parimad_aastad.png&quot;) ## Saving 7 x 5 in image Kui me soovime mõne muu graafiku salvestada kui viimasena trükitu, siis on meil võimalik iga graafik salvestada muutujasse nagu tabelidki ja siis anda ggsave funktsioonile see muutuja. p &lt;- top10 %&gt;% inner_join(artist_career,by=&quot;artist&quot;) %&gt;% mutate(artist=fct_reorder(artist,n)) %&gt;% ggplot()+ geom_segment(aes(x=artist,xend=artist,y=first,yend=last),size=3)+ coord_flip()+ theme_bw()+ labs(title=&quot;Eesti artistide karjäärid SkyPlus Top 40-s 1994-2019&quot;,x=&quot;&quot;,y=&quot;&quot;) ggsave(&quot;figures/top10_parimad_aastad.png&quot;,p) ## Saving 7 x 5 in image 7.4 Sõnastik data %&gt;% ggplot(aes(x=var1, y=var2)) + geom_point() märk - ggplot kihtide sidumiseks ggplot() - aluskiht geom_point() - punktgraafik, kus iga andmepunkt on punkt geom_line() - joongraafik, kus need punktid on mingil alusel ühendatud joontega geom_col() - tulpdiagramm, kus tulba suurus näitab väärtuse suurust geom_text() - lisab teksti graafikule. teksti asukohad on samuti x ja y telje järgi geom_tile() - ruudustikgraafik, kus x ja y telg määravad millise ruuduga on tegemist fct_reorder() - faktormuutuja tasemete järjestuse muutmiseks 7.5 Harjutusülesanded Tee graafik 2000ndate kõige populaarsematest artistidest selle alusel, mitu lugu edetabelisse sai. Vali üks artist ning tee ülevaade kõigist tema lugudest, mis said edetabelisse. Lisa tabelile tekstikiht loo nimedega. Vali üks artist ja tee tabel nende enim kasutatud sõnadest. Tee sama graafik nii et stopsõnad on eemaldatud. Tee sama graafik tf-idf märksõnade alusel. "]
]
